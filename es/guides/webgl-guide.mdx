---
title: Juego Web3 Aviator con WebGL
description: Aprende cómo integrar WebGL en un juego usando herramientas del
  Sequence Stack para ganar logros y usar ERC1155 personalizados.
sidebarTitle: Construye un Juego con WebGL
---

Tiempo para completar: 40 minutos

En esta guía veremos el proceso de integrar WebGL en un juego, aprovechando las herramientas del Sequence Stack para ganar logros y usar ERC1155 personalizados para jugar en el juego.

<Note>
  Puedes jugar una versión en vivo del juego [aquí](https://0xsequence.github.io/aviator-demo/)

  Donde el código completo de este juego se puede encontrar [aquí](https://github.com/0xsequence/aviator-demo/)

  Y el código completo de la plantilla que usaremos para la guía se puede encontrar [aquí](https://github.com/0xsequence-demos/template-webgl-js-sequence-kit-starter)
</Note>

Las herramientas te permitirán realizar:

1. [Project Setup With Webpack](/guides/webgl-guide#1-project-setup-with-webpack): Habilitar una estructura de proyecto con WebGL para ser compilada por Webpack
2. [Integrate Web SDK](/guides/webgl-guide#2-integrate-sequence-kit): Permitir que todas las EOAs y Sequence Wallet autentiquen al usuario
3. [Deploy a Collectibles Contract](/guides/webgl-guide#3-deploy-a-collectibles-contract): Crear tu propio contrato de coleccionables
4. [Deploy a Remote Minter and Mint In-game Tokens](/guides/webgl-guide#4-deploy-a-remote-minter-and-mint-in-game-achievement-tokens): Realizar transacciones sin gas retransmitidas con trabajadores de Cloudflare
5. [Leverage Items In-game](/guides/webgl-guide#5-leverage-items-in-game): Integrar coleccionables en el juego usando el Indexador de Sequence
6. [Burn In-game Achievement tokens](/guides/webgl-guide#6-burn-in-game-achievement-tokens): Quemar logros del juego con wagmi
7. [(Optional) Integrate Embedded Wallet Into Web SDK](/guides/webgl-guide#7-optional-integrate-embedded-wallet-into-sequence-kit): Habilitar una experiencia de usuario fluida sin el uso de mensajes firmados por el firmante

## 1. Configuración del proyecto con webpack

#### Clonar Repositorio

Primero comenzaremos clonando un proyecto plantilla, que tiene algunos componentes basados en WebGL creados usando `three`, todo compilado usando [webpack](https://webpack.js.org/)

[Template WebGL JS Web SDK Starter](https://github.com/0xsequence-demos/template-webgl-js-sequence-kit-starter/tree/simple-start)

Clona el repositorio anterior, `cd` dentro del repositorio con `cd template-webgl-js-sequence-kit-starter`

#### Actualizar `.env`

Crea un `.env` archivo (usando el `.env.example`) con las variables de entorno

```
PROJECT_ACCESS_KEY=
WALLET_CONNECT_ID=
```

Y, ejecuta los siguientes comandos para ejecutar la aplicación

```
# or your choice of package manager
pnpm install
pnpm run dev
```

Excelente, deberías ver un avión volando sobre el agua

## 2. Integrar Web SDK

Ahora que tenemos una estructura de proyecto configurada, podemos integrar Web SDK

#### Configurar `App.jsx` Componente

Crea una carpeta dentro de la `src` carpeta llamada `react` y crea 2 archivos: `App.jsx` y `Login.jsx`

En `App.jsx` incluye el siguiente código

```js
import React from "react";
import { useOpenConnectModal } from "@0xsequence/kit";
import { useDisconnect, useAccount } from "wagmi";
import Login from "./Login.jsx";

import { KitProvider } from "@0xsequence/kit";
import { getDefaultConnectors } from "@0xsequence/kit-connectors";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { createConfig, http, WagmiConfig } from "wagmi";
import { arbitrumSepolia, Chain } from "wagmi/chains";

const queryClient = new QueryClient();

function App(props) {
  const chains = [arbitrumSepolia];
  const projectAccessKey = process.env.PROJECT_ACCESS_KEY;

  const connectors = getDefaultConnectors("universal", {
    walletConnectProjectId: process.env.WALLET_CONNECT_ID,
    defaultChainId: 421614,
    appName: "demo app",
    projectAccessKey,
  });

  const transports = {};

  chains.forEach((chain) => {
    transports[chain.id] = http();
  });

  const config = createConfig({
    transports,
    connectors,
    chains,
  });

  return (
    <WagmiConfig config={config}>
      <QueryClientProvider client={queryClient}>
        <KitProvider config={{ defaultTheme: "dark" }}>
          <Login scene={props.scene} />
        </KitProvider>
      </QueryClientProvider>
    </WagmiConfig>
  );
}

export default App;
```

Luego, en el archivo `Login.jsx` agrega el siguiente código para crear un botón en la parte superior de la pantalla para iniciar sesión en la aplicación

```js
import React, { useEffect } from "react";
import { useOpenConnectModal, useKitWallets } from "@0xsequence/kit";
import { useWalletClient } from "wagmi";

function Login(props) {
  const { setOpenConnectModal } = useOpenConnectModal();
  const { data: walletClient } = useWalletClient();
  const {
    wallets, // Array of connected wallets
    linkedWallets, // Array of linked wallets (for embedded wallets)
    setActiveWallet, // Function to set a wallet as active
    disconnectWallet, // Function to disconnect a wallet
  } = useKitWallets();

  const isConnected = wallets.length;

  useEffect(() => {
    if (isConnected) {
      props.scene.login();
    } else {
      props.scene.logout();
    }
  }, [isConnected]);

  const sendBurnToken = async () => {
    // empty for now
  };

  useEffect(() => {
    if (isConnected && walletClient) {
      props.scene.sequenceController.init(walletClient, sendBurnToken);
    }
  }, [isConnected, walletClient]);

  return (
    <>
      <div style={{ textAlign: "center" }}>
        <br />
        {isConnected && (
          <div
            onClick={() => disconnectWallet(wallets[0].address) // assuming one wallet is connected. you can also disconnect a specific wallet from useKitWallets by specifying the address}
            style={{
              cursor: "pointer",
              position: "fixed",
              top: "30px",
              right: "30px",
              zIndex: "1",
            }}
          >
            sign out
          </div>
        )}
      </div>
    </>
  );
}

export default Login;
```

#### Renderizar Componente en Javascript `index.js`

Finalmente, agrega en el `index.js` importa el `App.jsx` componente, y renderízalo para ser agregado al elemento `root` id en `index.html`

```js
import * as ReactDOM from 'react-dom/client';
import App from './react/App.jsx'

...

const root = ReactDOM.createRoot(document.getElementById('root'))

root.render(
    <App scene={mainScene}/>
);
```

##### Crear un Manejador de Clics Para Llamar al Modal de Inicio de Sesión

Agrega el siguiente código al componente `Login.jsx` componente

```js
window.setOpenConnectModal = () => {
  setOpenConnectModal(true);
};
```

Y el siguiente código del manejador de clics a `index.js`

```ts
function handleMouseUp(event) {
  window.setOpenConnectModal();
}

document
  .getElementById("world")
  .addEventListener("mouseup", handleMouseUp, false);
```

Y agrega estos elementos a tu `index.html`

```html
<div id="mintBtn" className="btn" onclick="window.mintPlane()">mint plane</div>
<div id="mintAchievementBtn" className="btn" onclick="window.mintAchievement()">
  mint achievement
</div>
<div id="burnBtn" className="btn" onclick="window.burn()">burn achievement</div>

<div id="login">click to login</div>
<div className="world" id="world"></div>
```

Excelente, ahora tendrás un botón que hace aparecer un modal

## 3. Desplegar un Contrato de Coleccionables

Necesitarás crear un coleccionable desde el [Sequence Builder](https://sequence.build) lo cual se puede lograr con la siguiente [guía](/solutions/collectibles/contracts/deploy-an-item-collection)

Debemos crear 2 colecciones: 1 para tokens de logros y la otra para los aviones

## 4. Desplegar un Acuñador Remoto y Acuñar Tokens de Logros En-juego

Luego, para enviar transacciones a la blockchain de manera fluida y sin gas, implementa un [Cloudflare Worker](/guides/mint-collectibles-serverless) para acuñar elementos desde un contrato desplegado en el paso anterior, asegurándote de que la dirección del contrato de la API de transacciones se ingrese como un `Minter Role`

Permitiremos que haya múltiples rutas para acuñar coleccionables: un coleccionable de avión y un coleccionable de logro.

Esto se logra en el código agregando un par clave/valor de `isPlane` al cuerpo normal de la solicitud de cloudflare, y creando un adicional `if/else` en el trabajador de cloudflare.

Puedes ver el código para esto en este [repositorio de github](https://github.com/0xsequence-demos/template-webgl-js-sequence-kit-starter/blob/master/cloudflare/noisy-silence-ee19/src/index.ts#L80)

Para esta guía, ejecutaremos todo el código de cloudflare en un entorno de desarrollo local, lo cual se puede lograr iniciando el trabajador de cloudflare en la carpeta del proyecto nombrado, con:

```
wrangler dev
```

## 5. Aprovechar los Elementos En-juego

Esta sección se dividirá en 2 implementaciones de actualización de UI con cambios de propiedad de activos en el juego:

* Mostrar cambios del Avión basados en los activos de la Billetera
* Mostrando cambios en la interfaz de usuario basados en los activos de la Wallet

#### Mostrando cambios del Plane basados en los activos de la Wallet

Para implementar cambios en el juego basados en lo que posee el activo de la wallet, puedes implementar un botón que acuña un token, luego en la respuesta, verifica los cambios del indexador

En el `index.js` incluimos un botón adjunto al `onclick` atributo del elemento en index.html

```js
window.mintPlane = () => {
  const tokenID = 1;
  mainScene.sequenceController.callContract(tokenID, true, (res) => {
    mainScene.sequenceController.fetchPlaneTokens(tokenID);
  });
};
```

Donde `callContract` se encarga del minteo llamando a un fetch que está envuelto en un mutex para asegurar que 1 minteo ocurra a la vez, para prevenir múltiples clics, agregado a la `SequenceController` clase en `/API/SequenceController.js`

```js
import { Mutex, E_CANCELED} from 'async-mutex';

const mutexMinting = new Mutex();
...
async callContract(tokenId, isPlane, callback) {
  if(!mutexMinting.isLocked()){
    try {
      await mutexMinting.runExclusive(async () => {
        console.log('Minting token:', tokenId);
        const url = 'http://localhost:8787';
        const data = {
          address: this.walletAddress,
          tokenId: tokenId,
          isPlane: isPlane
        };

        try {
          const res = await fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
          })
          const txHash = await res.text();
          mutexMinting.release();
          callback(txHash);
        } catch(err) {
          mutexMinting.release();
          callback(err);
        }
      });
    } catch (err) {
      if (err === E_CANCELED) {
        mutexMinting.release();
      }
    }
  } else {
    console.log('mutex is locked')
  }
}
```

y `fetchPlaneTokens` consultará el resultado hasta que haya un activo en tu wallet, actualizando el `plane color` para representar un avión diferente.

`fetchPlaneTokens` está implementado con el siguiente código, donde la verificación condicional del balance es mayor que 1, y el `tokenID` es igual al id buscado.

Esta lógica condicional de UI cambiaría según tu aplicación

```js
import { SequenceIndexer } from '@0xsequence/indexer';
...
async fetchPlaneTokens(){

  // a polling wait
  const wait = (ms) => new Promise((res) => setTimeout(res, ms))
  let hasFoundPlane = false

  while(!hasFoundPlane) {
      const response = await this.indexer.getTokenBalances({
      accountAddress: this.walletAddress,
      contractAddress: '0x10ac72ada55ed46ee35deed371b8d215c2e870e1', // the collection address
    })
    await wait(1000)
    for(let i = 0; i < response.balances.length; i++){
      // a check on the inventory
      if(response.balances[i].tokenID == '1' && Number(response.balances[i].balance) > 0){
        // implement any UI update here
        this.scene.airplane.addPlane(Number(response.balances[i].tokenID))
        hasFoundPlane = true // breaks from the loop
      }
    }
  }
}
```

#### Mostrando Cambios de UI Basados en los Activos de la Wallet

A continuación, implementamos un cambio de UI donde agregamos un `burn achievement` botón, basado en si el usuario tiene un logro o no

Primero, implementa la lógica similar del manejador de clics html/js como antes

donde esta vez, el `isPlane` valor de `callContract` está establecido en `false`

```js
// index.js
window.mintAchievement = () => {
  const tokenID = 0;
  mainScene.sequenceController.callContract(tokenID, false, (res) => {
    mainScene.sequenceController.fetchTokensFromAchievementMint(tokenID);
  });
};
```

<Warning>
  Nota: en un juego real, este minteo del token de logro ocurriría basado en
  algún evento desencadenante en el juego, por simplicidad hemos incluido un botón
</Warning>

Esta vez, llamamos a `fetchTokensFromAchievementMint` que está agregado a la `SequenceController`

```js
  async fetchTokensFromAchievementMint(tokenID) {
    // check for achievement balance
    const wait = (ms) => new Promise((res) => setTimeout(res, ms))
    let hasFoundPlane = false
    let tokenIDs = []
    while(!hasFoundPlane) {
      const response = await this.indexer.getTokenBalances({
        accountAddress: this.walletAddress,
        contractAddress: '0x856de99d7647fb7f1d0f60a04c08340db3875340', // you achievements collection address
      })
      await wait(1000)
      for(let i = 0; i < response.balances.length; i++){
        // can update this logic to see if there is any balance: i.e. if(response.balances.length > 0)
        if(response.balances[i].tokenID == String(tokenID)){
          hasFoundPlane = true
          // making the button appear
          document.getElementById('burnBtn').style.display = 'flex'
        }
      }
    }
  }
```

Esto hace que solo si hay un balance devuelto por el indexador, el `display` atributo hace que aparezca el botón

## 6. Quemar Tokens de Logros del Juego

Finalmente, para quemar el token de logro, ya no podemos usar un worker de cloudflare para acciones enviadas a la blockchain, porque cuando el minteo se realizó 'en nombre de' la dirección usando la API de transacciones (haciendo el `msg.sender` en el contrato una de las `relayer` direcciones) para esto, queremos asegurarnos de que el `msg.sender` en el contrato pruebe la propiedad del token, y se envíe directamente desde el `user`. Usaremos `wagmi` funciones frontend así como algo de composición de clases para lograr esto.

```js
// index.js
window.burn = () => {
  const tokenID = 0;
  mainScene.sequenceController.burnToken(tokenID, (res) => {
    mainScene.sequenceController.fetchTokensFromBurn(tokenID);
  });
};
```

Donde `burnToken` es una función pasada desde nuestro componente react que usa el patrón similar de usar mutexes, y enviamos la transacción usando `sendTransaction` desde el `wagmi` paquete, y esperamos una actualización del hash de transacción para devolver el callback

```js
// react/Login.jsx
import {
    useAccount,
    useWalletClient,
    useSendTransaction,
} from 'wagmi';
import { useMutex } from 'react-context-mutex';
import { ethers } from 'ethers'
import { SequenceIndexer } from '@0xsequence/indexer';

let burnCallback = null
const ContractAddress = '0x856de99d7647fb7f1d0f60a04c08340db3875340';

function Login() {
  const MutexRunner = useMutex();
  const mutexBurn = new MutexRunner('sendMutexBurn');

  const { isConnected } = useAccount()
  const { data: walletClient } = useWalletClient();
  const { data: txnData, sendTransaction, isLoading: isSendTxnLoading } = useSendTransaction();

  useEffect(() => {
    if (isConnected && walletClient) {
        props.scene.sequenceController.init(
            walletClient,
            sendBurnToken
        );
    }
  }, [isConnected, walletClient]);

  const sendBurnToken = async (tokenID, callback) => {
      if(!mutexBurn.isLocked()){
          const contractABI = ['function burn(uint256 tokenId, uint256 amount)']; // Replace with your contract's ABI
          const contract = new ethers.Contract(ContractAddress, contractABI);

          // call indexer
          // check for achievement balance
          const indexer = new SequenceIndexer(
              'https://arbitrum-sepolia-indexer.sequence.app',
              process.env.PROJECT_ACCESS_KEY
          );

          const response = await indexer.getTokenBalances({
              accountAddress: walletClient.account.address,
              contractAddress: '0x856de99d7647fb7f1d0f60a04c08340db3875340',
          })

          const data = contract.interface.encodeFunctionData('burn', [
              tokenID,
              response.balances[0].balance, // get the balance from the indexer
          ]);

          try {
              mutexBurn.lock()
              burnCallback = callback
              await sendTransaction({
                  to: ContractAddress,
                  data: data,
                  value: '0',
                  gas: null,
              })
          } catch (error) {
              console.log(error)
          callback(error);
          }
      } else {
          console.log('burn in progress')
      }
  };

  useEffect(() => {
    if(txnData && burnCallback && mutexBurn.isLocked()) {
        mutexBurn.unlock();
        burnCallback(txnData)
    }
  }, [burnCallback, txnData])
...
}
```

Y en nuestro `SequenceController`, llama a la `sendBurnToken` función envuelta en `burnToken` para hacer la función react accesible al resto de la aplicación

```js
async burnToken(tokenID, callback) {
  this.sendBurnToken(tokenID, callback);
}

async init(walletClient, sendTransactionBurn) {
  this.walletAddress = walletClient.account.address;

  this.sendBurnToken = sendTransactionBurn;
}
```

Luego, para hacer que el token quemado tenga un efecto en la UI, ocultamos el botón usado para quemar el token en el lugar inicial, logrado con el siguiente código en el `SequenceController`

```js
async fetchTokensFromBurn(tokenID){
  const wait = (ms) => new Promise((res) => setTimeout(res, ms))
  let hasBeenBurned = false
  while(!hasBeenBurned) {
    let tokenIDs = [] // create an empty array to include all the tokens
    const response = await this.indexer.getTokenBalances({
      accountAddress: this.walletAddress,
      contractAddress: '0x856de99d7647fb7f1d0f60a04c08340db3875340',
    })
    await wait(1000)
    for(let i = 0; i < response.balances.length; i++){
        tokenIDs.push(response.balances[i].tokenID)
    }
    if(!tokenIDs.includes(String(tokenID))) { // check that the token id is not contained in the array
      hasBeenBurned = true
      // can apply any UI logic here
      document.getElementById('burnBtn').style.display = 'none' // hide the button
    }
  }
}
```

Y has terminado, puedes ver un ejemplo completo del código [aquí](https://github.com/0xsequence-demos/template-webgl-js-sequence-kit-starter)

## 7. (Opcional) Integrar Embedded Wallet en Web SDK

Si deseas hacer más fluida la experiencia del usuario para permitir que no haya firma de transacciones por parte del usuario en general, puedes habilitar una Embedded Wallet actualizando la configuración de tu componente react del Web SDK.

Al lograr esto, reducimos un pop-up al quemar tokens con `wagmi`, ya que la recompensa de tokens de logros y el minteo de coleccionables se completan usando un worker de cloudflare para transacciones sin gas.

Esto se puede lograr agregando algunas variables de entorno y cambiando el tipo de conector que usamos.

Primero actualiza tu `.env` archivo con los siguientes secretos de entorno

```
WAAS_CONFIG_KEY=
GOOGLE_CLIENT_ID=
APPLE_CLIENT_ID=
```

Luego pasa estas variables a tu conector Web SDK en `App.jsx`

```js

import { getKitConnectWallets } from '@0xsequence/kit';
import { getDefaultWaasConnectors } from '@0xsequence/kit-connectors';
import { createConfig, http, WagmiProvider } from 'wagmi';
...
const projectAccessKey = process.env.PROJECT_ACCESS_KEY_NEXT;
const waasConfigKey = process.env.WAAS_CONFIG_KEY;
const googleClientId = process.env.GOOGLE_CLIENT_ID;
const appleClientId = process.env.APPLE_CLIENT_ID;

function App(props) {

  const appleRedirectURI =
  'https://' + window.location.host + '/aviator-demo';

  const connectors = [
    ...getDefaultWaasConnectors({
      walletConnectProjectId: process.env.WALLET_CONNECT_ID,
      defaultChainId: 421614,
      waasConfigKey,
      googleClientId,
      appleClientId,
      appleRedirectURI,
      appName: 'demo app',
      projectAccessKey,
      enableConfirmationModal: false,
    }),
    ...getKitConnectWallets(projectAccessKey, []),
  ];

  const transports = {};

  chains.forEach(chain => {
    transports[chain.id] = http();
  });

  const config = createConfig({
    transports,
    connectors,
    chains,
  });

  return (
    <WagmiProvider config={config}>
    ...
    <WagmiProvider/>
  )
}
```

Y eso es todo, no se requiere más integración para completar los flujos de transacciones

<Note>
  Para aprender más sobre las Wallets En-Juego, ver
  [aquí](/solutions/wallets/embedded-wallet/overview)
</Note>
