---
title: Transacciones del Libro de Órdenes
description: Esta guía cubre la creación de un mercado personalizado utilizando herramientas
  del stack de Sequence. Incluye pasos para acuñar tokens, autenticación de billetera,
  consultas blockchain, tipos múltiples de billeteras, creación de solicitudes,
  aceptación de órdenes e integración opcional de una billetera integrada.
sidebarTitle: Construir un Mercado Personalizado
---

En esta guía recorreremos el proceso de crear un mercado personalizado utilizando algunas herramientas simples del stack de Sequence.

Las herramientas te permitirán realizar:

1. [Acuñación](/guides/custom-marketplace#1-minting): Acuñación de tokens en tu billetera desde Sequence Builder
2. [Autenticación de Billetera](/guides/custom-marketplace#2-wallet-authentication): Uso del Web SDK para autenticar un usuario
3. [Consultas Blockchain](/guides/custom-marketplace#3-blockchain-queries): Consulta de saldos de tokens usando el Indexer
4. [Tipos Múltiples de Billeteras](/guides/custom-marketplace#4-multi-wallet-types): Permitir a los usuarios usar una Sequence Wallet o una EOA
5. [Creación de Solicitudes](/guides/custom-marketplace#5-request-creation): Creación de solicitudes de venta en el Sequence Market Protocol
6. [Aceptación de Órdenes](/guides/custom-marketplace#6-order-accepting): Aceptación de órdenes principales del Marketplace
7. [(Opcional) Habilitar Billetera Integrada](/guides/custom-marketplace#7-optional-integrate-embedded-wallet-into-sequence-kit): Agregar una experiencia UX más fluida con transacciones sin confirmación

<Note>
  Mira un ejemplo [de una dapp de mercado simplificada](https://simple-marketplace-boilerplate.pages.dev/) que permite a los usuarios acuñar coleccionables, vender los coleccionables con el Sequence Marketplace Protocol, y realizar compras con USDC en `base-sepolia` obteniendo una orden principal del Marketplace.

  El código se puede encontrar [aquí](https://github.com/0xsequence-demos/simple-marketplace-boilerplate)
</Note>

## 1. Acuñación

El primer paso es crear un coleccionable desde Sequence Builder y acuñar algunos tokens, lo cual se puede lograr con esta [guía](/solutions/collectibles/contracts/deploy-an-item-collection) y usar el `tokenId` que acuñaste en los siguientes pasos para consultar y cumplir órdenes.

## 2. Autenticación de Billetera

Para tu proyecto, necesitarás una forma de autenticar a tu usuario con una billetera.

Tu elección del stack de Sequence es usar ya sea una [Embedded Wallet](/sdk/headless-wallet/quickstart) para una UX sin interfaz y similar a web2, o una [Ecosystem Wallet](/solutions/wallets/ecosystem/overview) con [Web SDK](/solutions/wallets/overview) para alcanzar más tipos de billeteras.

Para esta guía usaremos una `Universal Sequence Wallet` con `Web SDK` conector (con una opción para una `Embedded Wallet`) que puede autenticar usuarios usando autenticación de Google o Apple, además de billeteras traídas por el usuario como Coinbase o Metamask.

### Instalar Paquetes

Puedes crear un proyecto vanilla js/html/css desde una [plantilla como esta](https://github.com/moskalyk/vanilla-js-sequence-kit-starter) para una configuración con plantilla, o te guiaremos sobre cómo usar react desde cero aquí.

Comienza creando un proyecto en una carpeta de tu elección:

```
mkdir <project_name>
cd <project_name>
npx create-react-app . --template=typescript
```

Luego, comienza instalando los paquetes requeridos en el `<project_name> folder`

```
pnpm install @0xsequence/kit @0xsequence/kit-connectors wagmi ethers viem 0xsequence @tanstack/react-query
```

Luego en `src` junto a `index.tsx` en la carpeta, crea un `config.ts` archivo con el siguiente contenido:

```js
import { arbitrumSepolia, Chain } from 'wagmi/chains'
import { getDefaultConnectors } from '@0xsequence/kit-connectors'
import { createConfig, http } from 'wagmi'

const chains = [arbitrumSepolia] as [Chain, ...Chain[]]

const projectAccessKey = process.env.REACT_APP_PROJECTACCESSKEY!;
const walletConnectProjectId = process.env.REACT_APP_WALLETCONNECTID!;

const connectors = getDefaultConnectors( "universal", {
    walletConnectProjectId: walletConnectProjectId,
    defaultChainId: 421614,
    appName: 'demo app',
    projectAccessKey
})

const transports: any = {}

chains.forEach(chain => {
    transports[chain.id] = http()
})

const config = createConfig({
    transports,
    connectors,
    chains
})

export { config }

```

<Warning>
  Asegúrate de incluir un `.env` archivo en la raíz de tu proyecto para incluir secretos
  del cliente
</Warning>

Luego, importa el `config` para ser consumido por el `WagmiProvider` en el `index.tsx`

```js
import ReactDOM from "react-dom/client";
import { KitProvider } from "@0xsequence/kit";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { WagmiProvider } from "wagmi";
import App from './App'

import { config } from "./config";

const root = ReactDOM.createRoot(
  document.getElementById("root") as HTMLElement,
);

const queryClient = new QueryClient();

function Dapp() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <KitProvider config={{ defaultTheme: "light", signIn: { showEmailInput: false } }}>
          <App />
        </KitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}

root.render(
      <Dapp />
);
```

Y finalmente, agrega un botón en el `App.tsx` para hacer aparecer el modal del Web SDK

```js
import { useOpenConnectModal, useKitWallets } from "@0xsequence/kit";

function App() {
  const { address } = useAccount();
  const { setOpenConnectModal } = useOpenConnectModal();
  const {
    wallets, // Array of connected wallets
    linkedWallets, // Array of linked wallets (for embedded wallets)
    setActiveWallet, // Function to set a wallet as active
    disconnectWallet, // Function to disconnect a wallet
  } = useKitWallets();

  const isConnected = wallets.length;

  const connect = async () => {
    setOpenConnectModal(true);
  };

  return (
    <>
      {!isConnected && <button onClick={() => connect()}>Connect</button>}
      {address && address}
    </>
  );
}

export default App;
```

¡Excelente! Deberías tener una aplicación que puede autorizar a un usuario y devolver una dirección de billetera.

Ahora puedes probarlo con:

```
pnpm run start
```

## 3. Consultas Blockchain

Una vez que tengas uno o varios coleccionables acuñados, puedes consultar los datos desde la dirección del contrato de tu despliegue, que se puede encontrar aquí:

<Frame>
  ![copy contract address](/images/marketplace/copy_contract.png)
</Frame>

Puedes consultar datos usando el indexer, utilizando este código donde una dirección de cuenta y dirección de contrato (obtenida del contrato desplegado en Sequence Builder) se ingresan en la api del indexer

Esto será importante cuando estés determinando un `tokenID` para crear una solicitud en el marketplace, para esta demo asumiremos que estás tratando con un solo `tokenID`

```js
// Works in both a Webapp (browser) or Node.js:
import { SequenceIndexer } from "@0xsequence/indexer";

const indexer = new SequenceIndexer(
  "https://arbitrum-sepolia-indexer.sequence.app",
  "<access-key>"
);

// try any contract and account address you'd like :), as an example
const contractAddress = "<your_deploy_contract_address"; // "0x1693ffc74edbb50d6138517fe5cd64fd1c917709";
const accountAddress = address; // "0xc2be9cf6d9ee4fd211f88620760e829792659b16";

// query Sequence Indexer for all nft balances of the account on Polygon
const nftBalances = await indexer.getTokenBalances({
  contractAddress: contractAddress,
  accountAddress: accountAddress,
  includeMetadata: true,
});

console.log("collection of items:", nftBalances);
```

Donde la respuesta de la llamada al indexer, produce los siguientes datos:

<Accordion title="Example Response">
  * `contractType` (string) - el tipo de contrato (es decir, ERC20, ERC721, o ERC1155)
  * `contractAddress` (string) - la dirección del contrato del token
  * `accountAddress` (string) - la dirección de la cuenta que desplegó
  * `tokenID` (string) - el tokenID del token (siempre 0 si es ERC20)
  * `balance` (string) - el saldo del token
  * `blockHash` (string) - el hash merkle de la transacción del bloque cuando se implementó el token
  * `blockNumber` (number) - el número de bloque en el que se implementó el token
  * `chainId` (number) - el id de la cadena del token
  * `contractType`
    * `chainId` (number) - el id de la cadena del token
    * `address` (string) - la dirección del token
    * `name` (string) - nombre a nivel de contrato del token
    * `type` (string) - el tipo de contrato (es decir, ERC20, ERC721, o ERC1155)
    * `symbol` (string) - el símbolo del token
    * `decimals` (number) - el número de decimales que tiene el token
    * `logoURI` (string) - el logo del token mostrado en sequence.app
    * `deployed` (boolean) - si el token está implementado
    * `bytecodeHash` (string) - hash del bytecode de un contrato inteligente implementado en la blockchain
    * `extensions`
      * `link` (string) - el sitio web adjunto para enlazar al proyecto
      * `description` (string) - la descripción de metadatos del token
      * `ogImage` (string) - la imagen de banner para el token, renderizada en sequence.app
      * `originChainId` (number) - el id de la cadena de origen que representa el token
      * `originAddress` (string) - la dirección del contrato de origen que representa el token
      * `verified` (boolean) - si el token está verificado y es confiable
      * `verifiedBy` (string) - la fuente de verificación que indica por qué esto no es spam
  * `updatedAt` (date) - la última vez que se actualizó el indexador
  * `tokenMetadata`

    * `tokenId` (string) - el tokenID del token (siempre 0 si es ERC20)
    * `contractAddress` (string) - la dirección del contrato del token
    * `name` (string) - nombre a nivel de token
    * `description` (string) - la descripción del token
    * `image` (string) - la imagen como url del token
    * `decimals` (string) - el número de decimales para el token
    * `properties` (object) - un objeto que contiene las propiedades de los metadatos del token
    * `external_url` (string) - una url externa donde encontrar el token o más detalles
    * `updatedAt` (date) - la última vez que se actualizaron los metadatos del token
</Accordion>

## 4. Tipos de Multi-wallet

Debido al hecho de que estamos usando `Web SDK` para este ejemplo que te permite usar una wallet de Sequence, además de tu propia `EOA wallet`, el envío de transacciones a la blockchain será diferente debido al hecho de que con una `Sequence wallet`, puedes enviar transacciones por lotes para optimizar los costos de gas, mientras que con `wagmi` usando un EOA solo puedes enviar 1 transacción a la vez.

Para lograr esto, tomamos algunos pasos para crear una variable de estado local que verifica la wallet autorizada

```ts
import { useEffect } from "react";
import { useConnect, useAccount } from "wagmi";

function App() {
  const { isConnected } = useAccount();
  const { connectors } = useConnect();
  const [isSequence, setIsSequence] = useState<boolean>(false);

  useEffect(() => {
    connectors.map(async (connector) => {
      if ((await connector.isAuthorized()) && connector.id === "sequence") {
        setIsSequence(true);
      }
    });
  }, [isConnected]);
}
```

<Note>
  En el protocolo de Sequence Market, cuando creas un listado, se conoce como `request`, y cuando aceptas una solicitud se llama `order`.
</Note>

## 5. Creación de Solicitud

Para este ejemplo, usaremos `Arbitrum Sepolia USDC` del [faucet comunitario](https://faucet.circle.com/)

Dirígete allí primero para obtener algunos tokens, para que puedas hacer listados con tu solicitud

***

Luego, para crear una solicitud para el libro de órdenes, primero necesitaremos asegurarnos de habilitar el contrato del libro de órdenes del mercado con la aprobación para transferir tus tokens

Primero, verificamos que el mercado esté aprobado para el contrato, con algo de lógica

```js
const ERC1155Contract = '0x1693ffc74edbb50d6138517fe5cd64fd1c917709'
const MarketPlaceContract = '0xfdb42A198a932C8D3B506Ffa5e855bC4b348a712'

function App() {

  async function checkERC1155Approval(ownerAddress: string, operatorAddress: string) {
    const abi = [
      "function isApprovedForAll(address account, address operator) external view returns (bool)"
    ];
    const provider = new ethers.providers.JsonRpcProvider(`https://nodes.sequence.app/arbitrum-sepolia/${process.env.REACT_APP_PROJECT_ACCESSKEY}`);
    const contract = new ethers.Contract(ERC1155Contract, abi, provider);
    return await contract.isApprovedForAll(ownerAddress, operatorAddress);
  }

  const createRequest = async () => {
      ...
    if(await checkERC1155Approval(address!,MarketPlaceContract)){
      // is approved and only requires a single transaction
      ...
    } else { // is not approved, so requires multiple transactions

      if(isSequence) { .. perform multi-batch transactions
        ...
      } else { // is not a sequence wallet
        ...
      }
    }
  };

}
```

A continuación, necesitaremos crear la transacción con el ABI correcto para generar los datos de llamada esperados para las diferentes rutas de: no estar aprobado versus aprobado, y si es una wallet de sequence o no.

```ts
const [requestData, setRequestData] = useState<any>(null);

const createRequest = async () => {
  const sequenceMarketInterface = new ethers.Interface([
    "function createRequest(tuple(bool isListing, bool isERC1155, address tokenContract, uint256 tokenId, uint256 quantity, uint96 expiry, address currency, uint256 pricePerToken)) external nonReentrant returns (uint256 requestId)",
  ]);

  const amountBigNumber = ethers.parseUnits(String("0.01"), 6); // ensure to use the proper decimals

  const request = {
    isListing: true,
    isERC1155: true,
    tokenContract: ERC1155Contract,
    tokenId: 1,
    quantity: 1,
    expiry: Date.now() + 7 * 24 * 60 * 60 * 1000, // 1 day
    currency: ArbSepoliaUSDCContract,
    pricePerToken: amountBigNumber,
  };

  const data = sequenceMarketInterface.encodeFunctionData("createRequest", [
    request,
  ]);

  setRequestData(data); // we'll need this in the next step

  if (await checkERC1155Approval(address!, MarketPlaceContract)) {
    // is approved and only requires a single transaction

    sendTransaction({
      to: MarketPlaceContract,
      data: `0x${data.slice(2, data.length)}`,
      gas: null,
    });
  } else {
    // is not approved, so requires multiple transactions

    const erc1155Interface = new ethers.Interface([
      "function setApprovalForAll(address _operator, bool _approved) returns ()",
    ]);

    // is not approved
    const dataApprove = erc1155Interface.encodeFunctionData(
      "setApprovalForAll",
      ["0xfdb42A198a932C8D3B506Ffa5e855bC4b348a712", true]
    );

    const txApprove = {
      to: ERC1155Contract,
      data: dataApprove,
    };

    const tx = {
      to: MarketPlaceContract,
      data: data,
    };

    if (isSequence) {
      const wallet = sequence.getWallet();
      const signer = wallet.getSigner(421614);

      try {
        const res = signer.sendTransaction([txApprove, tx]);
        console.log(res);
      } catch (err) {
        console.log(err);
        console.log("user closed the wallet, or, an error occured");
      }
    } else {
      // is not a sequence wallet
      // todo: implement mutex

      sendTransaction({
        to: ERC1155Contract,
        data: `0x${dataApprove.slice(2, data.length)}`,
        gas: null,
      });
      // still need to send acceptRequest transaction
    }
  }
};
```

Finalmente, para la ruta donde la transacción no se realiza desde una wallet de sequence y no está aprobada, debemos enviar una transacción una vez que haya un recibo de transacción del `useSendTransaction` hook usando un mutex para confirmar de qué transacción provino el hash. Esto se hace en una función `useEffect` de react.

<Note>
  En programación informática, una exclusión mutua (mutex) es un objeto de programa que evita que múltiples hilos accedan al mismo recurso compartido simultáneamente.
</Note>

```ts
import { useSendTransaction } from 'wagmi'
import { useMutex } from 'react-context-mutex';

function App() {
  ...
  const [requestData, setRequestData] = useState<any>(null)
  const { data: hash, sendTransaction } = useSendTransaction()
  const MutexRunner = useMutex();
  const mutexApproveERC1155 = new MutexRunner('sendApproveERC1155');

  const createRequest = async () => {
    ...
    if(await checkERC1155Approval(address!,MarketPlaceContract)){
      ...
    } else {
      if (isSequence) { // is a sequence wallet
        ...
      } else { // is not a sequence wallet
        mutexApproveERC1155.lock()
        sendTransaction({
          to: ERC1155Contract,
          data: `0x${dataApprove.slice(2,data.length)}`,
          gas: null
        })
      }
    }
  };

  useEffect(() => {
    if (mutexApproveERC1155.isLocked() && hash) {
      sendTransaction({
        to: MarketPlaceContract,
        data: `0x${requestData.slice(2, requestData.length)}`,
        gas: null,
      });
      mutexApproveERC1155.unlock();
    }
  }, [requestData, hash]);
```

¡Genial! Has terminado de crear solicitudes al protocolo de Sequence Market, ahora puedes implementar un botón y probar el flujo.

## 6. Aceptación de Órdenes

Ahora que tenemos una orden en el mercado, necesitamos hacer algunas cosas:

* `Query the Marketplace`: consultar el mercado para una `orderId` para la que quieras aceptar una orden
* `Currency Balance`: verificar el saldo de la moneda usando el indexador
* `Token Approval`: verificar la aprobación de la moneda para que el mercado transfiera tokens

#### Consultar el Mercado

Vamos a consultar el libro de órdenes del mercado para obtener el `pricePerToken` y `orderId` para el que es la orden

```ts
  const getTopOrder = async (tokenID: string) => {
    const res = await fetch(
      "https://marketplace-api.sequence.app/arbitrum-sepolia/rpc/Marketplace/GetTopOrders",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          collectionAddress: ERC1155Contract,
          currencyAddresses: [ArbSepoliaUSDCContract],
          orderbookContractAddress: MarketPlaceContract,
          tokenIDs: [tokenID],
          isListing: true,
          priceSort: "DESC", // descending based on price to get lowest offer first
        }),
      },
    );
    const result = await res.json();
    return result.orders[0] // getting the first order from the list
  }

  const acceptOrder = async () => {
    const tokenID = '1'
    const topOrder: any = await getTopOrder(tokenID)
    const requiredAmount = topOrder.pricePerToken
    ...
    if(await checkERC20Balance(requiredAmount)){
      ...
    } else {
      ...
    }
  }
```

#### Saldo de Moneda

Usaremos el indexador para consultar el saldo y ver si el usuario tiene suficientes tokens para pagar la orden. Esto se puede lograr con el siguiente código:

<Warning>
  Deberás asegurarte de que cuando realices una comprobación de igualdad en la dirección del contrato del token, esta se ingrese en minúsculas
</Warning>

```js
import { SequenceIndexer } from '@0xsequence/indexer'
...
const checkERC20Balance = async (requiredAmount: any) => {
    const indexer = new SequenceIndexer('https://arbitrum-sepolia-indexer.sequence.app', process.env.REACT_APP_PROJECT_ACCESSKEY)

    const contractAddress = ArbSepoliaUSDCContract
    const accountAddress = address

    const tokenBalances = await indexer.getTokenBalances({
      contractAddress: contractAddress,
      accountAddress: accountAddress,
    })

    let hasEnoughBalance = false

    tokenBalances.balances.map((token) => {
      const tokenBalanceBN = ethers.BigNumber.from(token.balance);
      const requiredAmountBN = ethers.BigNumber.from(requiredAmount);
      if(token.contractAddress == ArbSepoliaUSDCContract && tokenBalanceBN.gte(requiredAmountBN)){
        hasEnoughBalance = true
      }
    })

    return hasEnoughBalance

}

const acceptOrder = async () => {
  const tokenID = '1'
  const topOrder: any = await getTopOrder(tokenID)
  const requiredAmount = topOrder.pricePerToken
  ...
  if(await checkERC20Balance(requiredAmount)){
  ...
  } else {
  ... // provide prompt on screen that user does not have balance
  }
}

```

#### Aprobación de Token

A continuación, verificaremos la aprobación del token para que el Marketplace pueda transferir el token de moneda

```ts
  const checkERC20Approval = async (ownerAddress: string, spenderAddress: string, tokenContractAddress: string, requiredAmount: string) => {
    const abi = [
      "function allowance(address owner, address spender) external view returns (uint256)"
    ];

    const provider = new ethers.providers.JsonRpcProvider(`https://nodes.sequence.app/arbitrum-sepolia/${process.env.REACT_APP_PROJECT_ACCESSKEY}`);
    const contract = new ethers.Contract(tokenContractAddress, abi, provider);
    const allowance = await contract.allowance(ownerAddress, spenderAddress);

    const requiredAmountBN = ethers.BigNumber.from(requiredAmount);
    const allowanceBN = ethers.BigNumber.from(allowance);

    return allowanceBN.gte(requiredAmountBN);
  }

  const acceptOrder = async () => {
    const tokenID = '1'
    const topOrder: any = await getTopOrder(tokenID)
    const requiredAmount = topOrder.pricePerToken

    if(await checkERC20Balance(requiredAmount)){
      if(!(await checkERC20Approval(address!,MarketPlaceContract,ArbSepoliaUSDCContract,requiredAmount))){
        ...
      } else {

      }
      else {

      }
    }
  }
```

Finalmente, completaremos la lógica necesaria enviando realmente una transacción a la blockchain

Comenzamos con el mismo flujo que antes, teniendo en cuenta el envío de transacciones múltiples por lotes si es una billetera sequence y no está aprobada, o, si el Marketplace está aprobado para gastar tus tokens, solo enviando una única transacción

```ts
  ...
  const mutexApproveERC20 = new MutexRunner('sendApproveERC20');
  ...
  const acceptOrder = async () => {
    const topOrder: any = await getTopOrder('1')
    const requiredAmount = topOrder.pricePerToken

    const sequenceMarketInterface = new ethers.Interface([
      "function acceptRequest(uint256 requestId, uint256 quantity, address recipient, uint256[] calldata additionalFees, address[] calldata additionalFeeRecipients)",
    ]);

    const quantity = 1
    const data = sequenceMarketInterface.encodeFunctionData(
      "acceptRequest",
      [topOrder.orderId, quantity, address, [], []],
    );

    setAcceptData(data) // we'll need this later, only for Web SDK enabled transactions

    const tx = {
      to: MarketPlaceContract, // 0xfdb42A198a932C8D3B506Ffa5e855bC4b348a712
      data: data
    }

    if(await checkERC20Balance(requiredAmount)){
      if((await checkERC20Approval(address!,MarketPlaceContract,ArbSepoliaUSDCContract,requiredAmount))){
        sendTransaction({
          to: MarketPlaceContract,
          data: `0x${data.slice(2,data.length)}`,
          gas: null
        })
      } else {
        ...
        const erc20Interface = new ethers.Interface([
          "function approve(address spender, uint256 amount) external returns (bool)"
        ]);

        const spenderAddress = "0xfdb42A198a932C8D3B506Ffa5e855bC4b348a712";
        const maxUint256 = ethers.constants.MaxUint256;
        const dataApprove = erc20Interface.encodeFunctionData("approve", [spenderAddress, maxUint256]);

        if(isSequence){
          const wallet = sequence.getWallet()
          const signer = wallet.getSigner(421614)

          const txApprove = {
            to: ArbSepoliaUSDCContract, // The contract address of the ERC-20 token, replace with actual contract address
            data: dataApprove
          };

          try {
            const res = await signer.sendTransaction([txApprove, tx])
            console.log(res)
          } catch (err) {
            console.log(err)
            console.log('user closed the wallet, or, an error occured')
          }
        } else {
          mutexApproveERC20.lock()

          sendTransaction({
            to: ArbSepoliaUSDCContract,
            data: `0x${dataApprove.slice(2,dataApprove.length)}`,
            gas: null
          })
        }
      }
    }
```

Luego en el flujo para no ser una billetera sequence y requerir aprobación, incluiremos otro`useEffect` con la verificación mutex implementada como antes

```ts
  ...
  const { data: hash, sendTransaction } = useSendTransaction()
  ...
  useEffect(() => {
    if (acceptData && mutexApproveERC20.isLocked()) {
      sendTransaction({
        to: MarketPlaceContract,
        data: `0x${acceptData.slice(2, acceptData.length)}`,
        gas: null,
      });
      mutexApproveERC20.unlock();
    }
  }, [hash, acceptData]);
```

Excelente, todo está completo si agregas el manejador de clic de función adjunto a un botón

## 7. (Opcional) Integrar Embedded Wallet en Web SDK

Para hacer que tu conector Web SDK sea compatible con[Embedded Wallet](/sdk/headless-wallet/quickstart), necesitaremos instalar algunas versiones de paquetes y actualizar nuestro`config.ts` que usamos al principio de la guía

La función Embedded Wallet permite transacciones sin confirmación, lo que puede crear una experiencia de usuario más fluida

```
pnpm i @0xsequence/kit@2.0.5-beta.9 @0xsequence/kit-connectors@2.0.5-beta.9
```

```ts
// config.ts
import { arbitrumSepolia, Chain } from "wagmi/chains";
import { getDefaultWaasConnectors } from "@0xsequence/kit-connectors"; // updated
import { createConfig, http } from "wagmi";
import { getKitConnectWallets } from "@0xsequence/kit"; // updated

const chains = [arbitrumSepolia] as [Chain, ...Chain[]];

// added environment variables
const projectAccessKey = process.env.REACT_APP_PROJECTACCESSKEY!;
const waasConfigKey = process.env.REACT_APP_WAASCONFIGKEY!;
const googleClientId = process.env.REACT_APP_GOOGLECLIENTID!;
const appleClientId = process.env.REACT_APP_APPLECLIENTID!;
const walletConnectProjectId = process.env.REACT_APP_WALLETCONNECTID!;
const appleRedirectURI = "https://" + window.location.host; // note: update slug to include correct homepage

const connectors = [
  ...getDefaultWaasConnectors({
    // updated connector type
    walletConnectProjectId: walletConnectProjectId,
    defaultChainId: 421614,
    waasConfigKey,
    googleClientId,
    appleClientId,
    appleRedirectURI,
    appName: "demo app",
    projectAccessKey,
    enableConfirmationModal: false,
  }),
  ...getKitConnectWallets(projectAccessKey, []),
];

const transports: any = {};

chains.forEach((chain) => {
  transports[chain.id] = http();
});

const config = createConfig({
  transports,
  connectors,
  chains,
});

export { config };
```

El último paso es asegurarse de actualizar a nuestro equipo con las URLs autorizadas de Google y Apple (por ejemplo,[http://localhost:3000](http://localhost:3000)) para llamar al flujo de inicio de sesión de Embedded Wallet
