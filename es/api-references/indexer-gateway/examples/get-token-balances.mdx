---
title: Sequence Indexer Gateway API - Fetch ERC20, ERC721, and ERC1155 Tokens
  and Metadata
description: La API de Tokens permite a los usuarios obtener una lista de tokens ERC20, ERC721 y
  ERC1155 junto con metadatos de cualquier billetera a través de múltiples redes
  Ethereum.
---

# Saldos de Tokens

En los siguientes ejemplos, vamos a usar el `GetTokenBalances` método de
Sequence Indexer Gateway:

## `GetTokenBalances`

* Solicitud: POST /rpc/IndexerGateway/GetTokenBalances
* Content-Type: application/json
* Cuerpo (en JSON):
  * `chainIds` (\[]int - opcional) -- devuelve resultados solo para las cadenas que coincidan con el ID dado.
  * `networks` (\[]string - opcional) -- devuelve resultados solo para las cadenas que coincidan con los nombres dados.
  * `accountAddress` (string) -- la dirección de la billetera
  * `contractAddress`: (string -- opcional) -- la dirección del contrato del token
  * `tokenID`: (string -- opcional) -- el ID del token
  * `includeMetadata` (boolean - opcional - predeterminado: false) -- activa la inclusión de metadatos del token en la respuesta
  * `includeCollectionTokens` (boolean - opcional - predeterminado: true) -- activa para representar tokens ERC721 / ERC1155 como un único elemento resumen en la respuesta
  * `metadataOptions` (object - opcional) -- opciones adicionales para metadatos
    * `verifiedOnly` (boolean - opcional) -- devuelve solo contratos que están 'verificados' para ayudar a reducir el spam
    * `unverifiedOnly` (boolean - opcional) -- devuelve solo contratos que están 'no verificados'
    * `includeContracts` (\[]string - opcional) -- lista de direcciones de contratos específicos que siempre se incluirán, incluso si verifiedOnly está habilitado.

Estos ejemplos están basados en el [ejemplo de Obtener Todos los Tokens](/api-references/indexer/examples/fetch-tokens) para Indexer.

### Obtener saldos de tokens y metadatos de una cuenta en múltiples redes Ethereum

Ejemplo: Recuperar saldos de tokens, junto con metadatos para la
`0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9` cuenta a través de todas las cadenas.

<CodeGroup>
  ```shell [Curl]
  curl -X POST \
    -H "Content-Type: application/json" \
    -H "X-Access-Key: AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY" \
    https://indexer.sequence.app/rpc/IndexerGateway/GetTokenBalances \
    -d '{
      "accountAddress": "0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9", 
      "includeMetadata": true,
      "metadataOptions": {
        "verifiedOnly": true
      }
    }'
  ```

  ```ts [Typescript]
  import { SequenceIndexerGateway } from '@0xsequence/indexer'

  const INDEXER_TOKEN = 'AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY';
  const ACCOUNT_ADDRESS = '0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9'

  const indexerGateway = new SequenceIndexerGateway(
    'https://indexer.sequence.app',
    INDEXER_TOKEN
  )

  const res = await indexerGateway.getTokenBalances({
    // chainIds: [1, 4, 137], /* limit results to specific chains */
    accountAddress: ACCOUNT_ADDRESS,
    includeMetadata: true,
    metadataOptions: {
      verifiedOnly: true
    }
  })

  res.balances.forEach(({chainId, results}) => {
    if (results.length === 0) {
      return
    }

    console.log(`chainId: ${chainId} → ${results.length} tokens found.`);
    results.forEach(token => {
      console.log(`\ttoken: ${token.contractAddress} (${token.contractInfo?.symbol}): ${token.balance}`);
    });
  })

  /*
  Sample output:
  chainId: 1946 → 1 tokens found.
          token: 0x5bcbc265a86fda3502e12cf17947445f7fd4402a (MINE): 1
  chainId: 421614 → 2 tokens found.
          token: 0x1f3abc3c5e4ac0601a21183380ed426e06ec694a (MINE): 2
    ""       token: 0x631980c251af5b4e71429ccc95f77155d75b89d4 (PCKX): 1
  */
  ```

  ```go [Go]
  package main

  import (
  	"context"
  	"fmt"
  	"log"
  	"net/http"

  	"github.com/0xsequence/go-sequence/indexer"
  )

  const indexerToken = "AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY"

  func main() {
  	ctx := context.TODO()

  	seqIndexerGW := indexer.NewIndexerGatewayClient(
  		"https://indexer.sequence.app",
  		http.DefaultClient,
  	)

  	authCtx, err := indexer.WithHTTPRequestHeaders(ctx, http.Header{
  		"X-Access-Key": []string{indexerToken},
  	})

  	includeMetadata := true
  	accountAddress := "0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9"

  	chainIDs := make([]uint64, 0)

  	// chainIDs = []uint64{1, 100, 137} // optional filter by chainID

  	metadataOptions := indexer.MetadataOptions{
  		VerifiedOnly: true,
  	}

  	_, tokenBalances, err := seqIndexerGW.GetTokenBalances(
      authCtx, 
      chainIDs,
      nil, 
      &accountAddress, 
      nil, 
      nil, 
      &includeMetadata, 
      &metadataOptions, 
      nil,
      nil,
    )
  	if err != nil {
  		log.Fatal(err)
  	}

  	for _, tb := range tokenBalances {
  		if len(tb.Results) == 0 {
  			continue
  		}
  		fmt.Printf("ChainID: %d -> %d tokens found\n", tb.ChainID, len(tb.Results))
  		for _, tokenBalance := range tb.Results {
  			fmt.Printf("\tToken: %q (%q): %s\n", tokenBalance.ContractAddress, tokenBalance.ContractInfo.Symbol, tokenBalance.Balance)
  		}
  	}
  }

  /*
  Sample output:
  ChainID: 1 -> 7 tokens found
          Token: "0xc770eefad204b5180df6a14ee197d99d808ee52d" ("FOX"): 58899592885266406938
          Token: "0x6b175474e89094c44da98b954eedeac495271d0f" ("DAI"): 5021334051688125324
          Token: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48" ("USDC"): 221887067
  */
  ```
</CodeGroup>

<br />

<Note>
  **CONSEJO PRO: obtención de IDs de tokens ERC721/1155**

  Notará que, por defecto, `GetTokenBalances` devolverá como máximo una
  instancia de token de cada contrato. Para obtener los saldos de tokens
  ERC721/1155, debe pasar el `contractAddress` al `GetTokenBalances` método.
  Esto devolverá todos los tokens que posee `accountAddress` del especificado
  `contractAddress`. Consulte la sección siguiente para más información.
</Note>

### Obtener IDs de tokens, saldos y metadatos de colecciones ERC721 y ERC1155.

Ejemplo: obtener saldos de tokens para una cuenta específica y contrato de token en la
red Polygon

<CodeGroup>
  ```shell [Curl]
  curl -X POST \
    -H "Content-Type: application/json" \
    -H "X-Access-Key: AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY" \
    https://indexer.sequence.app/rpc/IndexerGateway/GetTokenBalances \
    -d '{
      "chainIds": [137],
      "accountAddress": "0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9",
      "contractAddress": "0x631998e91476DA5B870D741192fc5Cbc55F5a52E",
      "includeMetadata": true,
      "metadataOptions": {
        "verifiedOnly": true
      }
    }'

  ```

  ```typescript [Typescript]
  import { SequenceIndexerGateway } from '@0xsequence/indexer'

  const INDEXER_TOKEN = 'AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY';
  const ACCOUNT_ADDRESS = '0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9';
  const CONTRACT_ADDRESS = '0x631998e91476DA5B870D741192fc5Cbc55F5a52E';

  const indexerGateway = new SequenceIndexerGateway(
    'https://indexer.sequence.app',
    INDEXER_TOKEN
  )

  const res = await indexerGateway.getTokenBalances({
    chainIds: [137],
    accountAddress: ACCOUNT_ADDRESS,
    contractAddress: CONTRACT_ADDRESS,
    includeMetadata: true,
    metadataOptions: {
      verifiedOnly: true
    }
  })

  res.balances.forEach(({ chainId, results }) => {
    if (results.length === 0) {
      return
    }

    console.log(`chainId: ${chainId} → ${results.length} tokens found.`);
    results.forEach(token => {
      console.log(`\ttoken: ${token.contractAddress} (${token.contractInfo?.symbol}): ${token.balance}`);
    });
  });

  ```

  ```go [Go]
  package main

  import (
  	"context"
  	"fmt"
  	"log"
  	"net/http"

  	"github.com/0xsequence/go-sequence/indexer"
  )

  const indexerToken = "AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY"

  func main() {
  	ctx := context.TODO()

  	seqIndexerGW := indexer.NewIndexerGatewayClient(
  		"https://indexer.sequence.app",
  		http.DefaultClient,
  	)

  	authCtx, err := indexer.WithHTTPRequestHeaders(ctx, http.Header{
  		"X-Access-Key": []string{indexerToken},
  	})
  	if err != nil {
  		log.Fatal(err)
  	}

  	includeMetadata := true
  	accountAddress := "0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9"
  	contractAddress := "0x631998e91476DA5B870D741192fc5Cbc55F5a52E"
  	chainIDs := []uint64{137}

  	metadataOptions := indexer.MetadataOptions{
  		VerifiedOnly: true,
  	}

  	_, tokenBalances, err := seqIndexerGW.GetTokenBalances(
  		authCtx,
  		chainIDs,
  		nil,
  		&accountAddress,
  		&contractAddress,
  		nil,
  		&includeMetadata,
  		&metadataOptions,
  		nil,
  		nil,
  	)
  	if err != nil {
  		log.Fatal(err)
  	}

  	for _, tb := range tokenBalances {
  		if len(tb.Results) == 0 {
  			continue
  		}
  		fmt.Printf("ChainID: %d -> %d tokens found\n", tb.ChainID, len(tb.Results))
  		for _, tokenBalance := range tb.Results {
  			fmt.Printf("\tToken: %q (%q): %s\n", tokenBalance.ContractAddress, tokenBalance.ContractInfo.Symbol, tokenBalance.Balance)
  		}
  	}
  }
  ```
</CodeGroup>
