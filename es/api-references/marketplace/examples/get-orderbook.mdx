---
title: GetOrderbookOrders
sidebarTitle: Obtener Orderbook
---

Con el uso de la `GetOrderbookOrders` api los desarrolladores pueden construir mercados personalizados alrededor de la api, como ejemplo, uno puede implementar un frontend para cumplir ciertas órdenes (no solo el mejor precio) para un coleccionable

<Frame>
  ![GetOrderbookOrders](/images/marketplace/custom-marketplace-listings.png)
</Frame>

### Ejemplo

`GetOrderbookOrders` de ids de tokens de una dirección de colección en Sepolia:

<Note>
  Nota: Si se usa la clave metadata.properties para filtrar, el uso de `min` y
  `max` es requerido para que las órdenes aparezcan en la consulta
</Note>

<CodeGroup>
  ```shell cURL

  curl --request POST \
    --url https://marketplace-api.sequence.app/arbitrum-sepolia/rpc/Marketplace/GetOrderbookOrders \
    --header 'Content-Type: application/json' \
    --data '{
      "collectionAddress": "0x1693ffc74edbb50d6138517fe5cd64fd1c917709",
      "currencyAddresses": [
          "0xa9c88358862211870db6f18bc9b3f6e4f8b3eae7"
      ],
      "filters": {
          "isListing": true,
          "tokenIds": [
              "0",
              "1",
              "4",
              "5"
          ]
      },
      "orderStatuses": [
          "OPEN","CANCELLED"
      ],
      "page": {
          "sort": [
              {
                  "column": "createdAt",
                  "order": "ASC"
              }
          ]
      },
      "orderbookContractAddress": "0xfdb42A198a932C8D3B506Ffa5e855bC4b348a712"
  }'
  ```

  ```js TypeScript
  // Works in both a Webapp (browser) or Node.js:
  import fetch from "cross-fetch";

  (async () => {
    const res = await fetch(
      "https://marketplace-api.sequence.app/polygon/rpc/Marketplace/GetOrderbookOrders",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          collectionAddress: "0x1693ffc74edbb50d6138517fe5cd64fd1c917709",
          currencyAddresses: ["0xa9c88358862211870db6f18bc9b3f6e4f8b3eae7"],
          filters: {
            isListing: true,
            tokenIds: ["1", "4", "5"],
          },
          orderStatuses: ["OPEN", "CLOSED"],
          page: {
            sort: [
              {
                column: "createdAt",
                order: "ASC",
              },
            ],
          },
          orderbookContractAddress: "0xfdb42A198a932C8D3B506Ffa5e855bC4b348a712",
        }),
      }
    );

    console.log("res", await res.json());
  })();
  ```
</CodeGroup>

### Esquema

Consulta el protocolo para órdenes basadas en varios filtros.

*Sequence Orderbook `GetOrderbookOrders` Método:*

* Solicitud: POST /rpc/Marketplace/GetOrderbookOrders
* Content-Type: application/json
* Cuerpo (en JSON):
  * `orderbookContractAddress` (string) -- la dirección del contrato del protocolo
  * `collectionAddress` (string) -- la dirección de la colección NFT
  * `currencyAddresses` (string\[]) -- un array de direcciones de contratos de moneda
  * `filters` (OrderbookOrderFilter) -- filtros para aplicar a la consulta
    * `tokenIds` (string\[]) -- los ids de tokens de los activos que estás buscando
    * `isListing?` (bool) -- `true` si es una orden, `false` si es una oferta
    * `userAddress?` (string) -- la dirección del usuario
  * `orderStatuses` (OrderStatus\[]) (opcional) -- filtrar órdenes por sus estados como `OPEN`, `CLOSED`, `CANCELLED` strings
  * `metadataFilter` (Filter) (opcional) -- filtrar órdenes por metadatos
    * `text?` (string) -- texto para buscar
    * `properties?` (PropertyFilter\[]) --
      * `name` (string) -- nombre de la propiedad, ej: hero
      * `type`: (PropertyType) -- tipo de los valores de la propiedad como enum de: `"INT"`,`"STRING"`,`"ARRAY"`, o `"GENERIC"`
      * `min?`: (int64) -- usado si el tipo es int, da rango de valores para filtrar
      * `max?`: (int64) -- usado si el tipo es int, da rango de valores para filtrar
      * `values?`: \[]any -- si es string entonces array de valores, ej: \["Ada", "Ari", "Axel", "Banjo" ...]
  * `beforeExpiryTimestamp` (int64) -- filtrar órdenes que expiran antes de la marca de tiempo dada
  * `page?` -- objeto de página para ordenar por
    * `sort` (Sort\[]) -- con un objeto de claves `"column"` y `"order"` con ejemplo `"createdAt"` y `"ASC"`, respectivamente
* Respuesta (en JSON):
  * `page`
    * `page` (i32) -- número de la página
    * `pageSize` (i32) -- número de órdenes en la página
    * `more` (bool) -- si hay más órdenes
  * `orders` (OrderbookOrder\[])
    \[
    * `orderId` (string) -- id de la orden
    * `tokenContract` (string) -- el contrato de la colección
    * `tokenId` (string) -- el tokenId de la colección en la orden
    * `isListing` (bool) -- es verdadero si es un listado para venta, o falso si es una oferta
    * `quantity` (string) -- el número de tokens que incluye la orden
    * `quantityRemaining` (string) -- el número de tokens después de la orden
    * `currencyAddress` (string) -- la moneda en la que se comercia el token
    * `pricePerToken` (string) -- el precio por token
    * `expiry` (string) -- la fecha de expiración cuando la orden ya no es válida
    * `orderStatus` (OrderStatus) -- el estado de la orden como enum de `"OPEN"`, `"CLOSED"`, `"CANCELLED"`
    * `createdBy` (string) -- la dirección por la que se creó la orden
    * `createdAt` (uint64) -- el tiempo en que se creó la orden
    * `orderbookContractAddress` (string) -- la dirección del contrato del libro de órdenes
      ]
