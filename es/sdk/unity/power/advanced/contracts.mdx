---
title: Contratos Inteligentes
---

Crear un `Contract` objeto para un contrato ya implementado es bastante sencillo.

```csharp
Contract contract = new Contract(contractAddress, abi);
```

Si bien no es estrictamente necesario, es <i>altamente</i> recomendable proporcionar el ABI del contrato como una cadena de texto al crear un objeto de contrato. No hacerlo impedirá que puedas aprovechar completamente nuestra codificación y decodificación ABI.
Si decides seguir este camino, necesitarás proporcionar la firma completa de la función (nombre de la función + tipos de parámetros entre paréntesis - por ejemplo, transfer(address,uint256) para el método de transferencia ERC20) al llamar a una función o consultar el contrato y solo recibirás una cadena como respuesta a las consultas.

## Llamando a Funciones de Contratos Inteligentes

Para llamar a un contrato inteligente, usarás el `CallFunction` método para crear un `CallContractFunction` objeto que determinará el gasPrice, gasLimit, nonce y datos apropiados para incluir en un `EthTransaction` recién ensamblado cuando se proporciona un cliente y un `ContractCall` objeto al `Create` Tarea asíncrona

Un ejemplo de llamada a un contrato inteligente se vería así:

```csharp
Contract erc20Contract = new Contract(contractAddress, contractAbi); // We'll use the well-known ERC20 contract as our example case
TransactionReceipt receipt = await erc20Contract.CallFunction("transfer", toAddress, amountAsBigInteger).SendTransactionMethodAndWaitForReceipt(wallet, client);
```

Nota: si no quieres esperar por el recibo, puedes usar `SendTransactionMethod` en su lugar.

Alternativamente, si solo quieres crear el `EthTransaction` y enviarlo en un momento posterior, puedes usar el `CallContractFunction` objeto desde `CallFunction` directamente.

```csharp
Contract erc20Contract = new Contract(contractAddress, contractAbi); // We'll use the well-known ERC20 contract as our example case
EthTransaction transaction = await erc20Contract.CallFunction("transfer", toAddress, amountAsBigInteger).Create(client, new ContractCall(wallet.GetAddress()));
TransactionReceipt receipt = await wallet.SendTransactionAndWaitForReceipt(client, transaction);

// or 
CallContractFunction transactionCreator = erc20Contract.CallFunction("transfer", toAddress, amountAsBigInteger);
EthTransaction transaction = await transactionCreator.Create(client, new ContractCall(wallet.GetAddress()));
TransactionReceipt receipt = await wallet.SendTransactionAndWaitForReceipt(client, transaction);

// or 
CallContractFunction transactionCreator = erc20Contract.CallFunction("transfer", toAddress, amountAsBigInteger);
TransactionReceipt receipt = await transactionCreator.SendTransactionMethodAndWaitForReceipt(wallet, client);
```

Notarás que el `CallFunction` método acepta un número arbitrario de argumentos. Deberás proporcionar los argumentos en el orden en que se proporcionan en la firma ABI/función.

## Entendiendo el Mapeo de Tipos de Datos

Al interactuar con contratos inteligentes, es importante entender cómo los tipos de datos de EVM se mapean a tipos de datos de C# en la biblioteca SequenceEthereum.

Si, por ejemplo, proporcionas una cadena donde el ABI espera un Integer, recibirás una excepción, incluso si esa cadena podría convertirse en un entero.

### Dirección

En C# puedes usar un tipo `string` o crear una instancia de `Address`. Asegúrate de que tu cadena sea hexadecimal
y comience con `0x` y tenga una longitud fija de 42 caracteres.

```csharp
Address address = new Address("0x123...");
```

### Enteros

Para tipos de enteros como `int256`, `uint8`, o `uint256` usas el `BigInteger` tipo de System.Numerics.

```csharp
// Simple number
BigInteger number = new BigInteger(10000);

// From hex
string hexString = "0x0000000...01";
BigInteger number = hexString.HexStringToBigInteger();
```

### Bytes

Para definir tipos de datos byte de Solidity en C#, tienes la opción de crear un `FixedByte` para tipos como `byte16` o `byte32`.
Cuando tu contrato requiere `bytes` puedes convertir cualquier valor en un `byte[]` de cualquier longitud.

Si tus datos están representados como una cadena hexadecimal en C#, asegúrate de usar nuestra función `HexStringToByteArray()` para convertir
el valor hexadecimal de vuelta al array de bytes original.

Para arrays de bytes como `byte32[]`, simplemente creas un `FixedByte[]` en C#.

```csharp
// byte16 or byte32
new FixedByte(16, new byte[] {});

// bytes
string someString = "abc0123456789";
byte[] bytes = someString.ToByteArray();

// signature
string signature = "0x0ab123...";
byte[] bytes = signature.HexStringToByteArray();
```

### Estructuras

Usas Tuplas para llamar a una función on-chain con una estructura. Aquí hay un ejemplo de estructura de Solidity y cómo definirla
usando el SDK de Unity de Sequence y pasarla como argumento en una función `Contract.CallFunction`.

Estructura en Solidity

```solidity
struct ExampleStruct {
    address wallet;
    uint256 amount;
    byte32 data;
}
```

Equivalente en C#

```csharp
Address wallet = new Address("0x...");
BigInteger amount = new BigInteger(10000);
FixedByte data = new FixedByte(32, byteArrayData);
var arg = new Tuple<Address, BigInteger, FixedByte>(wallet, amount, data);
```

### Otros Tipos

Para tipos de datos tradicionales en Solidity como `string` o `bool`, puedes usar los mismos tipos de datos en C#.

## Consultando Contratos

Para consultar un contrato inteligente (leer datos de él), usarás el método `SendQuery<T>` para consultar el contrato y devolver el resultado como tipo T (si es posible).
Un ejemplo de consulta a un contrato inteligente se vería así:

```csharp
Contract erc20Contract = new Contract(contractAddress, contractAbi); // We'll use the well-known ERC20 contract as our example case
BigIntegar balance = await erc20Contract.SendQuery<BigIntegar>(client, "balanceOf", address);
```

Alternativamente, si deseas simplemente construir la consulta y enviarla en un momento posterior, puedes usar `QueryContract<T>` para crear un delegado.

```csharp
Contract erc20Contract = new Contract(contractAddress, contractAbi); // We'll use the well-known ERC20 contract as our example case
QueryContractMessageSender<BigIntegar> balanceQuery = erc20Contract.QueryContract<BigIntegar>("balanceOf", address);
BigIntegar balance = await balanceQuery(client);
// or
BigIntegar balance = await balanceQuery.SendQuery(client);
```

## Implementando Contratos

Si quieres implementar un contrato, puedes usar el `ContractDeployer`

```csharp
ContractDeploymentResult deploymentResult = await ContractDeployer.Deploy(client, wallet, contractBytecodeAsString);
string newlyDeployedContractAddress = deploymentResult.Receipt.contractAddress;
```
