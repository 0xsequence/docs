---
title: useBuyModal
description: Hook para gestionar la interfaz del modal de compra de coleccionables
sidebarTitle: useBuyModal
---

## Importar

```typescript
import { useBuyModal } from "@0xsequence/marketplace-sdk/react";
```

## Uso

<Note>
  Asegúrese de haber seguido la guía de [Primeros pasos](https://docs.sequence.xyz/sdk/marketplace-sdk/getting-started) para obtener la dirección de la colección y el chainId.
</Note>

### Examples

<Tabs>
  <Tab title="Compra en el mercado">
    Ejemplo de cómo implementar una compra en el mercado (ventas secundarias) usando el hook `useBuyModal`:

    <Note>
      Este ejemplo utiliza el hook [`useLowestListing`](/sdk/marketplace-sdk/hooks/marketplace-data/useLowestListing) de marketplace-sdk. Si no existe un lowestListing con los parámetros indicados, significa que no hay un orderId disponible y, por lo tanto, el artículo no se puede comprar.
    </Note>

    <Steps>
      <Step title="Configurar el componente manejador con validación de la configuración del marketplace">
        Primero, cree un componente principal que se encargue de cargar y validar la configuración del marketplace:

        ```typescript
        import {
          useBuyModal,
          useLowestListing,
          useMarketplaceConfig,
        } from '@0xsequence/marketplace-sdk/react';
        import type { Address } from 'viem';

        function MarketPurchaseExample() {
          const { data: marketplaceConfig, isLoading: isMarketplaceConfigLoading } =
            useMarketplaceConfig();

          // Handle loading states
          if (isMarketplaceConfigLoading) {
            return <div style={{ padding: '20px' }}>Loading marketplace config...</div>;
          }

          if (!marketplaceConfig) {
            return (
              <div style={{ padding: '20px' }}>No marketplace config available</div>
            );
          }

          const collection = marketplaceConfig.market.collections[0];

          if (!collection) {
            return <div style={{ padding: '20px' }}>No collections available</div>;
          }

          const chainId = collection.chainId;
          const collectionAddress = collection.itemsAddress as Address;

          return (
            <MarketPurchase
              chainId={chainId}
              collectionAddress={collectionAddress}
              collectibleId="0"
            />
          );
        }
        ```
      </Step>

      <Step title="Crear el componente de compra del marketplace">
        A continuación, cree el componente real de compra del marketplace que utilice los datos validados correctamente:

        ```typescript
        interface MarketPurchaseProps {
          chainId: number;
          collectionAddress: Address;
          collectibleId: string;
        }

        function MarketPurchase({
          chainId,
          collectionAddress,
          collectibleId,
        }: MarketPurchaseProps) {
          const {
            data: lowestListing,
            isLoading: isLoadingLowestListing,
            isError: isErrorLowestListing,
          } = useLowestListing({
            collectionAddress,
            chainId,
            tokenId: collectibleId,
          });

          const { show: showMarketModal } = useBuyModal({
            onSuccess: ({ hash, orderId }) => {
              console.log('Market purchase successful', { hash, orderId });
            },
            onError: (error) => {
              console.error('Market purchase failed:', error.message);
            },
          });

          const handleMarketBuy = () => {
            if (!lowestListing || isLoadingLowestListing) return;

            showMarketModal({
              chainId,
              collectionAddress,
              collectibleId,
              orderId: lowestListing.orderId,
              marketplace: lowestListing.marketplace,
            });
          };

          if (isLoadingLowestListing) {
            return <div style={{ padding: '20px' }}>Loading listing...</div>;
          }

          if (isErrorLowestListing || !lowestListing) {
            return (
              <div style={{ padding: '20px' }}>
                Error loading listing or no listing found
              </div>
            );
          }

          return (
            <div style={{ padding: '20px' }}>
              <h3>Market Purchase</h3>

              <p>Price: ${lowestListing.priceUSDFormatted}</p>

              <button
                type="button"
                onClick={handleMarketBuy}
                disabled={isLoadingLowestListing || isErrorLowestListing}
              >
                Buy from Market
              </button>
            </div>
          );
        }
        ```
      </Step>
    </Steps>
  </Tab>

  <Tab title="Compra en la tienda">
    Ejemplo de cómo implementar una compra en la tienda (ventas primarias) usando el hook `useBuyModal`:

    <Note>
      Este ejemplo utiliza el hook [`useListPrimarySaleItems`](/sdk/marketplace-sdk/hooks/marketplace-data/useListPrimarySaleItems) de marketplace-sdk. El hook obtiene los artículos de venta primaria de un contrato específico. Si no existe un primarySaleItem con los parámetros indicados o si el suministro es 0, el artículo no se puede comprar.
    </Note>

    <Steps>
      <Step title="Configurar el componente manejador con validación de la configuración del marketplace">
        Primero, cree un componente principal que se encargue de cargar y validar la configuración del marketplace:

        ```typescript
        import {
          useBuyModal,
          useListPrimarySaleItems,
          useMarketplaceConfig,
        } from '@0xsequence/marketplace-sdk/react';
        import type { Address } from 'viem';

        function ShopPurchaseExample() {
          const { data: marketplaceConfig, isLoading: isMarketplaceConfigLoading } =
            useMarketplaceConfig();

          // Handle loading states
          if (isMarketplaceConfigLoading) {
            return <div style={{ padding: '20px' }}>Loading marketplace config...</div>;
          }

          if (!marketplaceConfig) {
            return (
              <div style={{ padding: '20px' }}>No marketplace config available</div>
            );
          }

          const collection = marketplaceConfig.shop.collections[0];

          if (!collection) {
            return <div style={{ padding: '20px' }}>No shop collections available</div>;
          }

          const chainId = collection.chainId;
          const collectionAddress = collection.itemsAddress as Address;
          const saleContractAddress = collection.saleAddress as Address;

          return (
            <ShopPurchase
              chainId={chainId}
              collectionAddress={collectionAddress}
              saleContractAddress={saleContractAddress}
              collectibleId="0"
            />
          );
        }
        ```
      </Step>

      <Step title="Crear el componente de compra en la tienda">
        Luego, cree el componente real de compra en la tienda que utilice los datos validados correctamente:

        ```typescript
        interface ShopPurchaseProps {
          chainId: number;
          collectionAddress: Address;
          saleContractAddress: Address;
          collectibleId: string;
        }

        function ShopPurchase({
          chainId,
          collectionAddress,
          saleContractAddress,
          collectibleId,
        }: ShopPurchaseProps) {
          const { show: showBuyModal } = useBuyModal({
            onSuccess: ({ hash }) => {
              console.log('Shop purchase successful', { hash });
            },
            onError: (error) => {
              console.error('Shop purchase failed:', error.message);
            },
          });

          // Fetch primary sale items
          const { data: primarySaleItems, isLoading: isLoadingPrimarySale } = useListPrimarySaleItems({
            chainId,
            primarySaleContractAddress: saleContractAddress,
            filter: {
              includeEmpty: true,
            },
          });

          const primarySaleItem =
            primarySaleItems?.pages[0]?.primarySaleItems[0]?.primarySaleItem;

          const handleShopBuy = () => {
            if (!primarySaleItem) return;

            showBuyModal({
              chainId,
              collectionAddress,
              salesContractAddress: saleContractAddress,
              cardType: 'shop',
              quantityDecimals: 0,
              quantityRemaining: Number(primarySaleItem.supply),
              items: [
                {
                  tokenId: collectibleId,
                  quantity: '1',
                },
              ],
              salePrice: {
                amount: primarySaleItem.priceAmount ?? '0',
                currencyAddress: (primarySaleItem.currencyAddress as Address) ?? '0x',
              },
            });
          };

          if (isLoadingPrimarySale) {
            return <div style={{ padding: '20px' }}>Loading primary sale items...</div>;
          }

          if (!primarySaleItem) {
            return (
              <div style={{ padding: '20px' }}>No primary sale items available</div>
            );
          }

          return (
            <div style={{ padding: '20px' }}>
              <h3>Shop Purchase</h3>

              <p>Available: {primarySaleItem.supply ?? 0}</p>

              <button
                type="button"
                onClick={handleShopBuy}
                disabled={!primarySaleItem || Number(primarySaleItem.supply) === 0}
              >
                Buy from Shop
              </button>
            </div>
          );
        }
        ```
      </Step>
    </Steps>
  </Tab>
</Tabs>

## Parámetros
El hook acepta un objeto opcional `callbacks` con las siguientes propiedades:

```typescript
interface ModalCallbacks {
  onSuccess?: ({ hash, orderId }: { hash?: Hash; orderId?: string }) => void;
  onError?: (error: Error) => void;
  successActionButtons?: Array<{ label: string; action: () => void }>;
}
```

| Parámetro                        | Type                                                             | Description                                                                        |
| -------------------------------- | ---------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| `callbacks.onSuccess`            | `({ hash, orderId }: { hash?: Hash; orderId?: string }) => void` | Función de callback opcional que se llama cuando la compra es exitosa              |
| `callbacks.onError`              | `(error: Error) => void`                                         | Función de callback opcional que se llama cuando ocurre un error durante la compra |
| `callbacks.successActionButtons` | `Array<{ label: string; action: () => void }>`                   | Arreglo opcional de botones de acción para mostrar en caso de éxito                |

## Tipo de retorno
El hook retorna un objeto con los siguientes métodos:

```typescript
{
  show: (args: BuyModalProps) => void
  close: () => void
}
```

### Métodos

#### show
`(args: BuyModalProps) => void`

Abre el modal de compra con los parámetros especificados. `BuyModalProps` puede ser `ShopBuyModalProps` o `MarketplaceBuyModalProps` dependiendo del tipo de compra.

Para compras en el mercado (ventas secundarias):

```typescript
interface MarketplaceBuyModalProps extends BuyModalBaseProps {
  marketplaceType?: "market";
  collectibleId: string;
  marketplace: MarketplaceKind;
  orderId: string;
}
```

Para compras en la tienda (ventas primarias):

```typescript
interface ShopBuyModalProps extends BuyModalBaseProps {
  marketplaceType: "shop";
  salesContractAddress: Address;
  items: Array<Partial<CheckoutOptionsItem> & { tokenId?: string }>;
  quantityDecimals: number;
  quantityRemaining: number;
  salePrice: {
    amount: string;
    currencyAddress: Address;
  };
  unlimitedSupply?: boolean;
}
```

Ambos tipos extienden de `BuyModalBaseProps`:

```typescript
interface BuyModalBaseProps {
  chainId: number;
  collectionAddress: Address;
  skipNativeBalanceCheck?: boolean;
  nativeTokenAddress?: Address;
  marketplaceType?: MarketplaceType;
  customCreditCardProviderCallback?: (buyStep: Step) => void;
  successActionButtons?: Array<{ label: string; action: () => void }>;
}
```

#### close
`() => void`

Cierra el modal de compra.

## Notas
El hook `useBuyModal` ofrece una forma práctica de gestionar la interfaz del modal de compra de coleccionables. Se encarga de:
- Abrir y cerrar el modal
- Gestionar el estado del flujo de compra
- Manejo de errores y callbacks de éxito
- Soporte tanto para ventas primarias como secundarias