---
title: useMetadataClient
description: Hook para acceder al cliente de Metadatos de Sequence para metadatos de tokens y contratos
sidebarTitle: useMetadataClient
---

## Importar

```tsx
import { useMetadataClient } from '@0xsequence/hooks'
```

## Uso

```tsx
import { useMetadataClient } from '@0xsequence/hooks'

function CustomMetadataFetcher() {
  const metadataClient = useMetadataClient()
  const [metadata, setMetadata] = useState(null)
  const [isLoading, setIsLoading] = useState(false)
  
  const fetchContractMetadata = async () => {
    setIsLoading(true)
    try {
      // Fetch metadata for a specific contract
      const response = await metadataClient.getContractInfo({
        chainID: "1",
        contractAddress: "0x..." 
      })
      
      setMetadata(response.contractInfo)
    } catch (error) {
      console.error('Failed to fetch metadata:', error)
    } finally {
      setIsLoading(false)
    }
  }

  // Example of batch token metadata fetch
  const fetchBatchTokenMetadata = async () => {
    setIsLoading(true)
    try {
      const response = await metadataClient.getTokenMetadata({
        chainID: "1",
        contractAddress: "0x...",
        tokenIDs: ["1", "2", "3"]
      })
      
      setMetadata(response.tokenMetadata)
    } catch (error) {
      console.error('Failed to fetch token metadata:', error)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div>
      <button 
        onClick={fetchContractMetadata}
        disabled={isLoading}
      >
        Fetch Contract Info
      </button>
      
      <button 
        onClick={fetchBatchTokenMetadata}
        disabled={isLoading}
      >
        Fetch Token Metadata
      </button>

      {isLoading && <div>Loading...</div>}
      
      {metadata && (
        <pre>
          {JSON.stringify(metadata, null, 2)}
        </pre>
      )}
    </div>
  )
}
```

## Tipo de Retorno: `SequenceMetadata`

El hook devuelve una instancia configurada del `SequenceMetadata` cliente. Aquí está la estructura detallada:

```tsx
interface SequenceMetadata {
  // Service Methods
  ping(headers?: object, signal?: AbortSignal): Promise<PingResponse>
  version(headers?: object, signal?: AbortSignal): Promise<VersionResponse>
  runtimeStatus(headers?: object, signal?: AbortSignal): Promise<RuntimeStatusReturn>
  
  // Task Management Methods
  getTask(args: GetTaskArgs, headers?: object, signal?: AbortSignal): Promise<GetTaskReturn>
  getTaskStatus(args: GetTaskStatusArgs, headers?: object, signal?: AbortSignal): Promise<GetTaskStatusReturn>
  
  // Token Metadata Methods
  getTokenMetadata(args: GetTokenMetadataArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenMetadataReturn>
  getTokenMetadataBatch(args: GetTokenMetadataBatchArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenMetadataBatchReturn>
  searchTokenMetadata(args: SearchTokenMetadataArgs, headers?: object, signal?: AbortSignal): Promise<SearchTokenMetadataReturn>
  searchTokenIDs(args: SearchTokenIDsArgs, headers?: object, signal?: AbortSignal): Promise<SearchTokenIDsReturn>
  tokenCollectionFilters(args: TokenCollectionFiltersArgs, headers?: object, signal?: AbortSignal): Promise<TokenCollectionFiltersReturn>
  
  // Token Refresh Methods
  refreshTokenMetadata(args: RefreshTokenMetadataArgs, headers?: object, signal?: AbortSignal): Promise<RefreshTokenMetadataReturn>
  enqueueTokensForRefresh(args: EnqueueTokensForRefreshArgs, headers?: object, signal?: AbortSignal): Promise<EnqueueTokensForRefreshReturn>
  getTokenRefreshStatus(args: GetTokenRefreshStatusArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenRefreshStatusReturn>
  getTokenRefreshResult(args: GetTokenRefreshResultArgs, headers?: object, signal?: AbortSignal): Promise<GetTokenRefreshResultReturn>
  cancelRefreshJob(args: CancelRefreshJobArgs, headers?: object, signal?: AbortSignal): Promise<CancelRefreshJobReturn>
  
  // Contract Methods
  getContractInfo(args: GetContractInfoArgs, headers?: object, signal?: AbortSignal): Promise<GetContractInfoReturn>
  getContractInfoBatch(args: GetContractInfoBatchArgs, headers?: object, signal?: AbortSignal): Promise<GetContractInfoBatchReturn>
  searchContractInfo(args: SearchContractInfoArgs, headers?: object, signal?: AbortSignal): Promise<SearchContractInfoReturn>
  searchContractInfoBatch(args: SearchContractInfoBatchArgs, headers?: object, signal?: AbortSignal): Promise<SearchContractInfoBatchReturn>
  refreshContractInfo(args: RefreshContractInfoArgs, headers?: object, signal?: AbortSignal): Promise<RefreshContractInfoReturn>
  refreshContractTokens(args: RefreshContractTokensArgs, headers?: object, signal?: AbortSignal): Promise<RefreshContractTokensReturn>
  refreshAllContractTokens(args: RefreshAllContractTokensArgs, headers?: object, signal?: AbortSignal): Promise<RefreshAllContractTokensReturn>
  
  // Search Methods
  searchMetadata(args: SearchMetadataArgs, headers?: object, signal?: AbortSignal): Promise<SearchMetadataReturn>
  searchTokens(args: SearchTokensArgs, headers?: object, signal?: AbortSignal): Promise<SearchTokensReturn>
  searchContracts(args: SearchContractsArgs, headers?: object, signal?: AbortSignal): Promise<SearchContractsReturn>
  
  // Niftyswap Methods
  getNiftyswapTokenQuantity(args: GetNiftyswapTokenQuantityArgs, headers?: object, signal?: AbortSignal): Promise<GetNiftyswapTokenQuantityReturn>
  getNiftyswapUnitPrices(args: GetNiftyswapUnitPricesArgs, headers?: object, signal?: AbortSignal): Promise<GetNiftyswapUnitPricesReturn>
  getNiftyswapUnitPricesWithQuantities(args: GetNiftyswapUnitPricesWithQuantitiesArgs, headers?: object, signal?: AbortSignal): Promise<GetNiftyswapUnitPricesWithQuantitiesReturn>
  
  // Mint Monitor Methods
  addContractToMintMonitor(args: AddContractToMintMonitorArgs, headers?: object, signal?: AbortSignal): Promise<AddContractToMintMonitorReturn>
  removeContractFromMintMonitor(args: RemoveContractFromMintMonitorArgs, headers?: object, signal?: AbortSignal): Promise<RemoveContractFromMintMonitorReturn>
  mintMonitorJobStatus(args: MintMonitorJobStatusArgs, headers?: object, signal?: AbortSignal): Promise<MintMonitorJobStatusReturn>
  mintMonitorTriggerJob(args: MintMonitorTriggerJobArgs, headers?: object, signal?: AbortSignal): Promise<MintMonitorTriggerJobReturn>
  
  // Contract Sync Methods
  syncContractTokens(args: SyncContractTokensArgs, headers?: object, signal?: AbortSignal): Promise<SyncContractTokensReturn>
  abortContractSync(args: AbortContractSyncArgs, headers?: object, signal?: AbortSignal): Promise<AbortContractSyncReturn>
  contractSyncJobStatus(args: ContractSyncJobStatusArgs, headers?: object, signal?: AbortSignal): Promise<ContractSyncJobStatusReturn>
  
  // Directory Methods
  directoryGetNetworks(args: DirectoryGetNetworksArgs, headers?: object, signal?: AbortSignal): Promise<DirectoryGetNetworksReturn>
  directoryGetCollections(args: DirectoryGetCollectionsArgs, headers?: object, signal?: AbortSignal): Promise<DirectoryGetCollectionsReturn>
  directorySearchCollections(args: DirectorySearchCollectionsArgs, headers?: object, signal?: AbortSignal): Promise<DirectorySearchCollectionsReturn>
}
```

### Métodos Disponibles

#### Métodos de Servicio

* `ping`: Verificar disponibilidad del servicio
* `version`: Obtener información de versión del servicio de metadatos
* `runtimeStatus`: Obtener estado actual de ejecución del servicio

#### Métodos de Gestión de Tareas

* `getTask`: Obtener detalles de una tarea específica
* `getTaskStatus`: Obtener estado de una tarea

#### Métodos de Metadatos de Tokens

* `getTokenMetadata`: Obtener metadatos para tokens específicos
* `getTokenMetadataBatch`: Obtener metadatos de tokens por lotes
* `searchTokenMetadata`: Buscar en metadatos de tokens
* `searchTokenIDs`: Buscar IDs de tokens específicos
* `tokenCollectionFilters`: Obtener filtros disponibles para colecciones de tokens

#### Métodos de Actualización de Tokens

* `refreshTokenMetadata`: Actualizar metadatos para tokens específicos
* `enqueueTokensForRefresh`: Poner tokens en cola para actualización de metadatos
* `getTokenRefreshStatus`: Verificar estado de actualización de tokens
* `getTokenRefreshResult`: Obtener resultados de actualización de tokens
* `cancelRefreshJob`: Cancelar un trabajo de actualización en curso

#### Métodos de Contrato

* `getContractInfo`: Obtener metadatos para un solo contrato
* `getContractInfoBatch`: Obtener metadatos de contratos por lotes
* `searchContractInfo`: Buscar en metadatos de contratos
* `searchContractInfoBatch`: Búsqueda por lotes de metadatos de contratos
* `refreshContractInfo`: Actualizar metadatos de contrato
* `refreshContractTokens`: Actualizar tokens para un contrato
* `refreshAllContractTokens`: Actualizar todos los tokens de un contrato

#### Métodos de Búsqueda

* `searchMetadata`: Buscar en todos los metadatos
* `searchTokens`: Buscar tokens específicos
* `searchContracts`: Buscar contratos específicos

#### Métodos de Niftyswap

* `getNiftyswapTokenQuantity`: Obtener información de cantidad de tokens de Niftyswap
* `getNiftyswapUnitPrices`: Obtener precios unitarios de Niftyswap
* `getNiftyswapUnitPricesWithQuantities`: Obtener precios unitarios con cantidades de Niftyswap

#### Métodos de Monitoreo de Acuñación

* `addContractToMintMonitor`: Agregar contrato al monitoreo de acuñación
* `removeContractFromMintMonitor`: Eliminar contrato del monitoreo de acuñación
* `mintMonitorJobStatus`: Verificar estado del trabajo de monitoreo de acuñación
* `mintMonitorTriggerJob`: Activar un trabajo de monitoreo de acuñación

#### Métodos de Sincronización de Contratos

* `syncContractTokens`: Sincronizar tokens para un contrato
* `abortContractSync`: Abortar una sincronización de contrato en curso
* `contractSyncJobStatus`: Verificar estado de sincronización de contrato

#### Métodos de Directorio

* `directoryGetNetworks`: Obtener redes disponibles
* `directoryGetCollections`: Obtener directorio de colecciones
* `directorySearchCollections`: Buscar en el directorio de colecciones

## Parámetros

El hook no acepta ningún parámetro pero usa la configuración del `useConfig` hook:

```tsx
interface Config {
  env: {
    metadataUrl: string
    // ... other environment settings
  }
  projectAccessKey: string
  jwt?: string
}
```

La configuración determina:

* La URL del servicio de metadatos
* La clave de acceso de tu proyecto para autenticación
* JWT opcional para solicitudes autenticadas

El cliente está memorizado basado en el `projectAccessKey` y `jwt` para prevenir re-instanciación innecesaria.
