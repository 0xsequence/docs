Explicit sessions give a signer the ability to perform calls within a defined scope. Explicit permissions become part of the session configuration and therefore the wallet configuration, and so require a wallet configuration update to be made. The permissions must be explicitly defined and accepted by the user in order to be used (thus the name).

The session manager in the SDK is smart enough to sign multiple calls by multiple sessions. If one session has permissions for approving an ERC20 and another session has access to a marketplace contract, these calls can be combined in a single payload automatically. 

Each call must match at least 1 permission. When matching a permission, the target address and **all** rules must validate. 

## Examples

Below are some example permissions for common use cases. The type definition of the permission is:

```tsx
export enum ParameterOperation {
  EQUAL = 0,
  NOT_EQUAL = 1,
  GREATER_THAN_OR_EQUAL = 2,
  LESS_THAN_OR_EQUAL = 3,
}

export type ParameterRule = {
  cumulative: boolean
  operation: ParameterOperation
  value: Bytes.Bytes
  offset: bigint
  mask: Bytes.Bytes
}

export type Permission = {
  target: Address.Address
  rules: ParameterRule[]
}

export type SessionPermissions = {
  signer: Address.Address
  valueLimit: bigint
  deadline: bigint
  permissions: [Permission, ...Permission[]]
}
```

`Permission.SELECTOR_MASK`, `Permission.ADDRESS_MASK`  and `Permission.UINT256_MASK` are provided in the SDK for convenience. 

### Deadline

Every permission must list a `deadline` which states when the permission is valid until. A `deadline` of `0` indicates the permission is available forever. 

The ecosystem wallet may decide what is an appropriate deadline. For example, the wallet may choose to warn the user when a request is made for a session with a deadline that exceeds 1 day, or/and may choose to prevent deadlines exceeding 1 week. 

```tsx
const deadline = BigInt(Math.floor(Date.now() / 1000) + 3600) // 1 hour from now
```

### Value (ETH) Transfer

Every permission must list a `valueLimit` which determines how much of the native token (i.e. ETH) is allowed to be sent. Multiple calls may be made with the total cumulative value sent up to this limit. 

The ecosystem wallet may warn a user whenever a non zero value is being requested. 

To send to an address, the permission `target` is set to the receiver. This also works for contracts with payable functions. If the receiver is not known in advance, the `target` can be a value forwarder contracts such as [0xdb8cB1A9cEb374A5Fc0eCb98bb0369e456452da0](https://arbiscan.io/address/0xdb8cB1A9cEb374A5Fc0eCb98bb0369e456452da0). 

```tsx
return {
  signer,
  valueLimit: 1000000000000000000n, // 1 ETH
  deadline,
  permissions: [
    {
      target: target, // The receiver
      rules: [], // No rules required
    },
  ],
}
```

In this example, the permission has unrestricted access when sending call data to the `target`. For payable functions, such as the forwarder, you may want to specify a selector rule to limit which functions can be called (see below examples) or specify a selector of `0x00000000` which will match empty call data. 

### ERC20

ERC20 has multiple ways to access value. As permissions validate call data, the encoding of the permission is different depending on whether the user wants to use `approve(address spender, uint256 value)`, `transfer(address to, uint256 value)` or `transferFrom(address from, address to, uint256 value)`. 

In general, the permission should consist of two rules:

- a rule matching the selector
- a cumulative less than or equal rule on value

The wallet app should be smart enough to detect a permission using a selector validation rule (`offset: 0`, `mask: Permission.SELECTOR_MASK`), decode the value and display the permission scope in a human readable format for the user. 

The wallet should be conscious of existing approvals. If one explicit signer approves access to a

Here is an example for the ERC20 using `transfer`.

```tsx
const erc20TransferAbi = AbiFunction.from('function transfer(address to, uint256 value) returns (bool)')
return {
  signer,
  valueLimit: 0,
  deadline,
  permissions: [
    {
      target: erc20Address,
      rules: [
        {
	        // The selector match rule
          cumulative: false,
          operation: Permission.ParameterOperation.EQUAL,
          value: Bytes.fromHex(AbiFunction.getSelector(erc20TransferAbi), { size: 32 }),
          offset: 0n,
          mask: Permission.SELECTOR_MASK,
        },
        {
          // The value limit rule
          cumulative: true, // Record the values across multiple calls.
          operation: Permission.ParameterOperation.LESS_THAN_OR_EQUAL,
          value: Bytes.fromNumber(10000000n, { size: 32 }), // 10 USDC (6 decimals)
          offset: 4n + 32n, // Offset the selector and to address
          mask: Permission.UINT256_MASK,
        },
      ],
    },
  ],
}
```

Note that the `offset` in the value rule is `4` (the selector is bytes4) `+ 32` (the address is encoded in 32 bytes) so that the rule will check the `uint256 value` in the call data. For the `transferFrom` function, you need to use `4 + 32 + 32` to get the correct offset for the value parameter. 

Also the `value` must include the correct number of decimals for the token.

You could also add a rule validating `address to` to the permission to ensure the ERC20 tokens can only be sent or accessed by a given address. 

Encoding multiple permissions for a single ERC20 will grant access to the total sum across the permissions. e.g. Having a `transfer` and a `transferFrom` permission for 10 USDC each, will result in 20 USDC being able to be accessed. 

### Marketplace Purchase

Requesting permissions for a Sequence Marketplace purchase requires knowing the `requestId` up front. The permission is unable to scope to a specific type of NFT (for example). 

The permission can enforce that the recipient of the purchase is the wallet address, and that the purchase is not made on behalf of another address. 

A set of permissions may be granted that allows accepting multiple requests. This, coupled with an ERC20 approve permission, could allow a signer the ability to purchase up to some value within a set list of listings. 

```tsx
const acceptRequestAbi = AbiFunction.from('acceptRequest(uint256 requestId, uint256 quantity, address recipient, uint256[] calldata additionalFees, address[] calldata additionalFeeRecipients)')
const marketplacePermissions = requestIds.map(requestId => ({
  target: marketplaceAddress,
  rules: [
    {
	    // Selector rule
      cumulative: false,
      operation: Permission.ParameterOperation.EQUAL,
      value: Bytes.fromHex(AbiFunction.getSelector(acceptRequestAbi), { size: 32 }),
      offset: 0n,
      mask: Permission.SELECTOR_MASK,
    },
    {
	    // Request Id rule
      cumulative: false,
      operation: Permission.ParameterOperation.EQUAL,
      value: Bytes.fromNumber(requestId, { size: 32 }), // requestId
      offset: 4n,
      mask: Permission.UINT256_MASK,
    },
    {
	    // Recipient rule
      cumulative: false,
      operation: Permission.ParameterOperation.EQUAL,
      value: Bytes.fromHex(wallet.address, { size: 32 }), // wallet.address
      offset: 4n + 32n + 32n,
      mask: Permission.ADDRESS_MASK,
    },
  ],
})
return {
  signer,
  valueLimit: 0,
  deadline,
  // erc20ApprovePermission as defined in the earlier example
  permissions: [erc20ApprovePermission, ...marketplacePermissions],
}
```

### Swaps

`// TODO AnyPay` 

Sessions are unable to sign messages. At the time of writing, Uniswap requires a signed message to be used and so explicit sessions can’t work without also calling the wallet for a signature, which kind of defeats the point of using an explicit session here. 

### One Time Use Hack

You can “hack” the permission structure to grant a permission that is only usable once. Set the permission to use `culumative: true`, `operation: Permission.ParameterOption.EQUAL` on the selector with `mask: Permission.SELECTOR` and `offset: 0`. On use, the session manager contract will record the use of the selector and update the offset. Subsequent calls with this permission will fail as the selector (with the increment) will no longer match. 

In this example, the session will be allowed to open 1 pack. 

```tsx
const packCommitAbi = AbiFunction.from('function commit()')
return {
  signer,
  valueLimit: 0,
  deadline,
  permissions: [
    {
      target: packAddress,
      rules: [
        {
          cumulative: true,
          operation: Permission.ParameterOperation.EQUAL,
          value: Bytes.fromHex(AbiFunction.getSelector(packCommitAbi), { size: 32 }),
          offset: 0n,
          mask: Permission.SELECTOR_MASK,
        },
      ],
    },
  ],
}
```

Note that this does not prevent a subsequent permissions being issued for the same selector. This single use limitation is only within the scope of the permission. 

To allow 2 calls, simply repeat this permission within the array. (Untested)