---
title: "useBuyModal"
description: "Hook for managing the buy modal interface for collectible purchases"
sidebarTitle: "useBuyModal"
---

## Import

```typescript
import { useBuyModal } from "@0xsequence/marketplace-sdk/react";
```

## Usage

<Note>
  Make sure you have followed the [Getting
  Started](https://docs.sequence.xyz/sdk/marketplace-sdk/getting-started) guide
  to get the collection address and chainId.
</Note>

### Examples

<Tabs>
  <Tab title="Market Purchase">
    Example of implementing a market purchase (secondary sales) using the `useBuyModal` hook:

    <Note>
      This example uses the [`useLowestListing`](/sdk/marketplace-sdk/hooks/marketplace-data/useLowestListing) hook from marketplace-sdk. If there is no lowestListing with the given parameters, it means there is no orderId available, and therefore the item cannot be bought.
    </Note>

```typescript
import type { MarketplaceKind } from "@0xsequence/marketplace-sdk";
import {
  useBuyModal,
  useLowestListing,
} from "@0xsequence/marketplace-sdk/react";
import type { Address } from "viem";

export default function MarketPurchaseExample() {
  const { data: marketplaceConfig, isLoading: isMarketplaceConfigLoading } =
    useMarketplaceConfig();

  const collection = marketplaceConfig?.market.collections[0];
  const chainId = collection?.chainId as number;
  const collectionAddress = collection?.itemsAddress as Address;
  const collectibleId = "0";
  const {
    data: lowestListing,
    isLoading: isLoadingLowestListing,
    isError: isErrorLowestListing,
  } = useLowestListing({
    collectionAddress,
    chainId,
    tokenId: collectibleId,
  });
  const orderId = lowestListing?.orderId as string;
  const marketplace = lowestListing?.marketplace as MarketplaceKind;
  const priceUSDFormatted = lowestListing?.priceUSDFormatted as string;

  const { show: showMarketModal } = useBuyModal({
    onSuccess: ({ hash, orderId }) => {
      console.log("Market purchase successful", { hash, orderId });
    },
    onError: (error) => {
      console.error("Market purchase failed:", error.message);
    },
  });

  const handleMarketBuy = () => {
    if (!lowestListing || isLoadingLowestListing) return;

    showMarketModal({
      chainId,
      collectionAddress,
      collectibleId,
      orderId,
      marketplace,
    });
  };

  return (
    <div style={{ padding: "20px" }}>
      <h3>Market Purchase</h3>

      <p>Price: ${priceUSDFormatted}</p>

      <button
        type="button"
        onClick={handleMarketBuy}
        disabled={isLoadingLowestListing || isErrorLowestListing}
      >
        Buy from Market
      </button>
    </div>
  );
}
```

  </Tab>
  <Tab title="Shop Purchase">
    Example of implementing a shop purchase (primary sales) using the `useBuyModal` hook:

    <Note>
      This example uses the [`useListPrimarySaleItems`](/sdk/marketplace-sdk/hooks/marketplace-data/useListPrimarySaleItems) hook from marketplace-sdk. The hook fetches primary sale items from a specific contract. If there is no primarySaleItem with the given parameters or if the supply is 0, the item cannot be bought.
    </Note>

```typescript
import {
  useBuyModal,
  useListPrimarySaleItems,
} from "@0xsequence/marketplace-sdk/react";
import type { Address } from "viem";

export default function ShopPurchaseExample() {
  const { data: marketplaceConfig, isLoading: isMarketplaceConfigLoading } =
    useMarketplaceConfig();

  const collection = marketplaceConfig?.shop.collections[0];
  const chainId = collection?.chainId as number;
  const collectionAddress = collection?.itemsAddress as Address;
  const saleContractAddress = collection?.saleAddress as Address;
  const collectibleId = "0";

  const { show: showBuyModal } = useBuyModal({
    onSuccess: ({ hash }) => {
      console.log("Shop purchase successful", { hash });
    },
    onError: (error) => {
      console.error("Shop purchase failed:", error.message);
    },
  });

  // Fetch primary sale items - replace parameters with your own
  const { data: primarySaleItems } = useListPrimarySaleItems({
    chainId: chainId,
    primarySaleContractAddress: saleContractAddress,
    filter: {
      includeEmpty: true,
    },
  });

  const primarySaleItem =
    primarySaleItems?.pages[0]?.primarySaleItems[0]?.primarySaleItem;

  const handleShopBuy = () => {
    if (!primarySaleItem) return;

    showBuyModal({
      chainId: chainId,
      collectionAddress: collectionAddress,
      salesContractAddress: saleContractAddress,
      cardType: "shop",
      quantityDecimals: 0,
      quantityRemaining: Number(primarySaleItem.supply),
      items: [
        {
          tokenId: collectibleId,
          quantity: "1",
        },
      ],
      salePrice: {
        amount: primarySaleItem.priceAmount ?? "0",
        currencyAddress: (primarySaleItem.currencyAddress as Address) ?? "0x",
      },
    });
  };

  return (
    <div>
      <p>Available: {primarySaleItem?.supply ?? 0}</p>
      <button
        type="button"
        onClick={handleShopBuy}
        disabled={!primarySaleItem || Number(primarySaleItem.supply) === 0}
      >
        Buy from Shop
      </button>
    </div>
  );
}
```

  </Tab>
</Tabs>

## Parameters

The hook accepts an optional `callbacks` object with the following properties:

```typescript
interface ModalCallbacks {
  onSuccess?: ({ hash, orderId }: { hash?: Hash; orderId?: string }) => void;
  onError?: (error: Error) => void;
  successActionButtons?: Array<{ label: string; action: () => void }>;
}
```

| Parameter                        | Type                                                             | Description                                                                |
| -------------------------------- | ---------------------------------------------------------------- | -------------------------------------------------------------------------- |
| `callbacks.onSuccess`            | `({ hash, orderId }: { hash?: Hash; orderId?: string }) => void` | Optional callback function called when the purchase is successful          |
| `callbacks.onError`              | `(error: Error) => void`                                         | Optional callback function called when an error occurs during the purchase |
| `callbacks.successActionButtons` | `Array<{ label: string; action: () => void }>`                   | Optional array of action buttons to show on success                        |

## Return Type

The hook returns an object with the following methods:

```typescript
{
  show: (args: BuyModalProps) => void
  close: () => void
}
```

### Methods

#### show

`(args: BuyModalProps) => void`

Opens the buy modal with the specified parameters. The `BuyModalProps` can be either `ShopBuyModalProps` or `MarketplaceBuyModalProps` depending on the purchase type.

For market purchases (Secondary sales):

```typescript
interface MarketplaceBuyModalProps extends BuyModalBaseProps {
  marketplaceType?: "market";
  collectibleId: string;
  marketplace: MarketplaceKind;
  orderId: string;
}
```

For shop purchases (Primary sales):

```typescript
interface ShopBuyModalProps extends BuyModalBaseProps {
  marketplaceType: "shop";
  salesContractAddress: Address;
  items: Array<Partial<CheckoutOptionsItem> & { tokenId?: string }>;
  quantityDecimals: number;
  quantityRemaining: number;
  salePrice: {
    amount: string;
    currencyAddress: Address;
  };
  unlimitedSupply?: boolean;
}
```

Both types extend from `BuyModalBaseProps`:

```typescript
interface BuyModalBaseProps {
  chainId: number;
  collectionAddress: Address;
  skipNativeBalanceCheck?: boolean;
  nativeTokenAddress?: Address;
  marketplaceType?: MarketplaceType;
  customCreditCardProviderCallback?: (buyStep: Step) => void;
  successActionButtons?: Array<{ label: string; action: () => void }>;
}
```

#### close

`() => void`

Closes the buy modal.

## Notes

The `useBuyModal` hook provides a convenient way to manage the buy modal interface for collectible purchases. It handles:

- Opening and closing the modal
- Managing the purchase flow state
- Error handling and success callbacks
- Support for both primary and secondary sales
