---
title: ガスレスなサーバーレストランザクションAPIを使用したコレクティブルのミント
description: Sequenceを使用してガスレスなサーバーレストランザクションAPIでコレクティブルをミントする方法を学びます。ユーザーがガス代を支払うことなくシームレスな操作を実現するために、Cloudflareワーカー上でAPIを実装します。
sidebarTitle: コレクティブルミントサービスの構築
---

所要時間: 20-30分

Sequence トランザクションAPIはサーバーレスな[Cloudflare](https://cloudflare.com/)ワーカーに実装でき、確認署名やガス代の支払いなしでゲームやアプリのユーザーインタラクションをシームレスに行うことができます。また、リレーヤーによるトランザクションの速度、スループット、再編成を心配する必要がなく、Cloudflareによる自動スケーリングの恩恵も受けられます。

以下の手順で、4ステップでホストされたミンターAPIの構築方法を説明します：

1. [Wrangler Cliを使用したCloudflare環境のセットアップとテストのデプロイ](/guides/mint-collectibles-serverless#1-setup-cloudflare-environment-with-wrangler-cli-and-deploy-a-test)
2. [Sequence Builderを使用したERC1155コントラクトのデプロイ、スポンサー、メタデータの更新](/guides/mint-collectibles-serverless#2-deploy-sponsor-and-update-metadata-for-an-erc1155-contract-with-sequence-builder)
3. [EOA DDoSを防ぐためのEthAuthProofの使用](/guides/mint-collectibles-serverless#3-use-ethauthproof-to-prevent-eoa-ddos)
4. [ウォレットへのコレクティブルのミント](/guides/mint-collectibles-serverless#4-mint-a-collectible-to-wallet)

結果として、以下の仕様を持つセキュアなAPI:

* HTTPS GET: blockNumberを返す
* HTTPS POST(proof, address): コレクティブルをミントしトランザクションハッシュを返す

<Warning>
  この実装を完了するには、wrangler cli、npm、Sequence Builderの基本的な知識が必要です。
</Warning>

<Note>
  [完全なコードはこちらをご覧ください](https://github.com/0xsequence-demos/template-cloudflare-worker-sequence-transactions-api)
</Note>

## 1. Wrangler Cliを使用したCloudflare環境のセットアップとテストのデプロイ

プロジェクトを最初から作成するには、まずプロジェクトを作成し`mkdir`、`cd`プロジェクトに移動し、`pnpm init`を実行して`package.json`を作成します。

次に、プロジェクトにwrangler cliがインストールされていることを確認し、`wrangler`キーワードをローカルのbashセッションでエイリアスとして設定します。

```shell
pnpm install wrangler --save-dev
alias wrangler='./node_modules/.bin/wrangler'
```

サイトで[Cloudflareサイト](https://cloudflare.com/)のアカウントを作成し、ログインステップを実行してCloudflareダッシュボードにログインし、ローカル開発環境をCloudflareプラットフォームに接続します。

```shell
wrangler login
```

ログインしたら、気に入ったランダムに生成されたプロジェクトフォルダ名の1つを受け入れてディレクトリでプロジェクトを初期化し、プロンプトに従ってgitで追跡されるtypescript`"Hello World" Worker`アプリケーションを初期化します。

```shell
wrangler init
```

このステップを完了するには、`wrangler init`の後にEnterを4回押し、最後の2ステップは`No`でgitバージョン管理とデプロイを拒否します。

これにより、クラウドにコードをデプロイするために使用できるスターターリポジトリがクローンされます。

<Note>
  ローカルAPIテスト<br />

  ガイドのどの時点でも、`wrangler dev`コマンドをプロジェクトフォルダで使用してローカルテストができます
</Note>

#### テストのデプロイ

最後に、`cd`ランダムに生成されたプロジェクトフォルダに移動し、`wrangler deploy`コマンドを実行します。

これによりURLが表示されるはずです。ブラウザでそのURLを`https://<app>.<account>.workers.dev`入力して`Hello World!`結果を確認できます。

## 2. Sequence Builderを使用したERC1155コントラクトのデプロイ、スポンサー、メタデータの更新

<Warning>
  トランザクションAPIを使用するには、Sequence Builderでプロジェクトの請求を`Developer`にアップグレードする必要があります。これは[このウォークスルー](/support/builder/project-settings#5-billing-settings)
</Warning>

まず、[このガイド](/solutions/collectibles/contracts/deploy-an-item-collection)に従ってコントラクトをデプロイします。

次に、ミンターウォレットアドレスからのリクエストのみを受け付けるように、Builderでコントラクトのロールアクセスを更新する必要があります。これは2つのステップで行えます。

これはSequence Builderで`minter permission`を提供して`Sequence Wallet Transactions API Address`できます。

使用するトランザクションAPIアドレスを知るには、まず以下のいずれかを行う必要があります：

1. この[アプリ](https://sequence-ethauthproof-viewer.vercel.app/)を使用してネットワークを選択し、`generate local wallet`ボタンでウォレットキーを生成する（デモ目的のみ）
2. `Recommended`：以下のコードスニペットを使用して、EOAウォレットの秘密鍵から生成されたアカウントアドレスをローカルで表示することもできます：

```ts
import { Session } from "@0xsequence/auth";
import { ethers } from "ethers";

(async () => {
  // Generate a new EOA
  // const wallet = ethers.Wallet.createRandom()
  // const privateKey = wallet.privateKey

  // Or, use an existing EOA private key
  const privateKey = "";

  // Open a Sequence session, this will find or create
  // a Sequence wallet controlled by your server EOA
  const session = await Session.singleSigner({
    signer: privateKey,
    projectAccessKey: "access_key",
  });

  const signer = session.account.getSigner(1);
  console.log(`Your transactions API wallet address: ${signer.account.address}`);
})();
```

これを行うには、プロジェクトを開き、`Contracts`ページに移動し、`Linked contracts`を選択し、`Write Contract` タブを展開して`grantRole`メソッド。

以下の詳細を入力してください：

`bytes32 role`: `0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6`

`address account`: `<Generated Sequence Transactions API Wallet Address>`

<Frame>
  <img src="/images/relayer/grant_role.png" alt="Grant a role for the relayer" />
</Frame>

ここで`role`文字列は`keccak256("MINTER_ROLE")`のSolidityでの結果、または`ethers.keccak256(ethers.toUtf8Bytes("MINTER_ROLE"))`のJavaScriptでの結果です

これにより、特定のアドレスのみがコントラクトからミントできるようになり、それ以外の場合はエラーが発生します。

をクリックして`write`スポンサードトランザクションに署名してロールの更新を完了します。

#### メタデータの更新

次に、コントラクトのメディアやアセットでメタデータを更新する必要があります。これは[このガイドに従って](/solutions/collectibles/metadata/manage-metadata-builder)。

#### コントラクトのスポンサリング

最後に、コントラクトをスポンサーするには[このガイド](/solutions/builder/gas-tank)に従ってコントラクトをスポンサーしてください。

## 3. EthAuthProofを使用してEOA DDoSを防止する

コントラクトがデプロイされたので、Cloudflare Workerのディレクトリとプロジェクトに戻り、`ethers`と`0xsequence`をインストールして、Sequence APIにアクセスし、リクエストが信頼できるソース（Sequenceウォレット）からのものであることを証明する検証を実行できるようにします。

```shell
pnpm install 0xsequence @0xsequence/network
```

次に、POSTまたはGETリクエストかどうかをチェックした後、ミドルウェアの種類を追加する必要があります。POSTリクエストの場合、渡された`proofString`と`address`および環境変数が有効であることを確認します。

に配置されるコードのスカフォールドは`src/index.ts`のようになります。`callContract`と`getBlockNumber`はモックアウトされており、コントラクトの呼び出しの前に`verify`を呼び出す検証ステップを使用します。

```ts
import { sequence } from "0xsequence";
import { networks, findSupportedNetwork } from "@0xsequence/network";

export interface Env {
  PKEY: string; // Private key for EOA wallet
  CONTRACT_ADDRESS: string; // Deployed ERC1155 or ERC721 contract address
  PROJECT_ACCESS_KEY: string; // From sequence.build
  CHAIN_HANDLE: string; // Standardized chain name – See https://docs.sequence.xyz/multi-chain-support
}

// use the sequence api to verify proof came from a sequence wallet
const verify = async (
  chainId: string,
  walletAddress: string,
  ethAuthProofString: string
): Promise<Boolean> => {
  const api = new sequence.api.SequenceAPIClient("https://api.sequence.app");
  const { isValid } = await api.isValidETHAuthProof({
    chainId,
    walletAddress,
    ethAuthProofString,
  });
  return isValid;
};

async function handleRequest(
  request: Request,
  env: Env,
  ctx: ExecutionContext
): Promise<Response> {

  if (request.method === "OPTIONS") {
		return new Response(null, {
			headers: {
				// Allow requests from any origin - adjust this as necessary
				"Access-Control-Allow-Origin": "*",
				
				// Allows the headers Content-Type, your-custom-header
				"Access-Control-Allow-Headers": "Content-Type, your-custom-header",
				
				// Allow POST method - add any other methods you need to support
				"Access-Control-Allow-Methods": "POST",
				
				// Optional: allow credentials
				"Access-Control-Allow-Credentials": "true",
				
				// Preflight cache period
				"Access-Control-Max-Age": "86400", // 24 hours
			}
		});
	}

  if (env.PKEY === undefined || env.PKEY === "") {
    return new Response("Make sure PKEY is configured in your environment", {
      status: 400,
    });
  }

  if (env.CONTRACT_ADDRESS === undefined || env.CONTRACT_ADDRESS === "") {
    return new Response(
      "Make sure CONTRACT_ADDRESS is configured in your environment",
      { status: 400 }
    );
  }

  if (env.PROJECT_ACCESS_KEY === undefined || env.PROJECT_ACCESS_KEY === "") {
    return new Response(
      "Make sure PROJECT_ACCESS_KEY is configured in your environment",
      { status: 400 }
    );
  }

  if (env.CHAIN_HANDLE === undefined || env.CHAIN_HANDLE === "") {
    return new Response(
      "Make sure CHAIN_HANDLE is configured in your environment",
      { status: 400 }
    );
  }

  const chainConfig = findSupportedNetwork(env.CHAIN_HANDLE);

  if (chainConfig === undefined) {
    return new Response("Unsupported network or unknown CHAIN_HANDLE", {
      status: 400,
    });
  }

  // POST request
  if (request.method === "POST") {
    // parse the request body as JSON
    const body = await request.json();
    const { proof, address, tokenId }: any = body;
    try {
      // check that the proof is valid
      if (await verify(env.CHAIN_HANDLE, address, proof)) {
        try {
          // mocked call
          const res = await callContract(request, env, address, tokenId);
          return new Response(`${res.hash}`, { status: 200 });
        } catch (err: any) {
          console.log(err);
          return new Response(`Something went wrong: ${JSON.stringify(err)}`, {
            status: 400,
          });
        }
      } else {
        return new Response(`Unauthorized`, { status: 401 });
      }
    } catch (err: any) {
      return new Response(`Unauthorized ${JSON.stringify(err)}`, {
        status: 401,
      });
    }
  }
  // GET request
  else {
    try {
      // mocked call
      const res = await getBlockNumber(env.CHAIN_HANDLE, request);
      return new Response(`Block Number: ${res}`);
    } catch (err: any) {
      return new Response(`Something went wrong: ${JSON.stringify(err)}`, {
        status: 500,
      });
    }
  }
}

const getBlockNumber = async (
  chainId: string,
  request: Request
): Promise<number> => {
  return chainId;
};

const callContract = async (
  request: Request,
  env: Env,
  address: string,
  tokenId: number
): Promise<ethers.providers.TransactionResponse> => {
  return { hash: "0x" } as any;
};

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext) {
    // Process the request and create a response
    const response = await handleRequest(request, env, ctx);

    // Set CORS headers
    response.headers.set("Access-Control-Allow-Origin", "*");
    response.headers.set(
      "Access-Control-Allow-Methods",
      "GET, POST, PUT, DELETE, OPTIONS"
    );
    response.headers.set("Access-Control-Allow-Headers", "Content-Type");

    // return response
    return response;
  },
};
```

#### Cloudflare環境変数の追加

次に、`[vars]`セクションを`wrangler.toml`で更新して、ビルドの環境変数を渡します。

```
[vars]
PKEY = "" # Private key for EOA wallet
CONTRACT_ADDRESS = "" # // Deployed ERC1155 or ERC721 contract address
PROJECT_ACCESS_KEY = "" # From sequence.build
CHAIN_HANDLE = "" # // Standardized chain name – See https://docs.sequence.xyz/multi-chain-support
```

#### Wranglerテンプレートでのウィンドウオブジェクトの実装

注意点として、デプロイを試みると、web3モジュールで必要な`window`オブジェクトが見つからないというエラーが発生します。

これを防ぐには、`wrangler.toml`ファイルに以下の行を追加して、環境を互換性のあるものにします。

```
...
node_compat = true # add this line
...
```

#### デプロイのテスト

これで`wrangler deploy`

以下のようなcurlリクエストでエンドポイントをテストできます：

```shell
curl -X POST https://your-worker.your-subdomain.workers.dev \
-H "Content-Type: application/json" \
-d '{"proof": "<some_proof>", "address": "<some_address>", "tokenId": 0 }'

... invalid proof string ...

# and if you replace with actual proof (from a wallet client login) and address on polygon, it should return
success
```

ウォレットアドレスの証明は、この[dapp](https://sequence-ethauthproof-viewer.vercel.app/)を使用して、以下の手順に従って取得できます。

#### ETHAuthProof Viewer dappの使用

ページに到着したら、最初にネットワークを選択する必要があります。

その後、接続して証明を生成するか、ローカルウォレットを生成するかのオプションがあります

<Frame>
  ![ETHAuthProof Viewer](/images/relayer/ethauthproof_viewer_connect.png)
</Frame>

ボタンを押して、`connect`を押してから`copy to clipboard`。

<Frame>
  ![ETHAuthProof Viewer copy to clipboard](/images/relayer/ethauthproof_viewer_copy.png)
</Frame>

注意点として、この`ETHAuthProof`を他人と共有しないことをお勧めします。これは、誰かがあなたのウォレットの所有権を証明し、特定のAPIと対話できることを意味するためです。

最後に、`url`を[このステップ](/guides/mint-collectibles-serverless#deploy-test)のアプリで、`<some_proof>`をビューアーdappからコピーした生成値で、`<some_address>`をあなたのウォレットアドレスで置き換えると、モックされた`0x`文字列が返されるはずです。

```shell
curl -X POST https://your-worker.your-subdomain.workers.dev \
-H "Content-Type: application/json" \
-d '{"proof": "<some_proof>", "address": "<some_address>", "tokenId": 0 }'
```

## 4. ウォレットにコレクティブルをミントする

最後に、スポンサードコントラクトアドレスからコレクティブルをデプロイしてミントするために、以下のパッケージをインストールします

```shell
pnpm install @0xsequence/auth ethers
```

そして、`callContract`と`getBlockNumber`メソッドを以下のように実装します：

```ts
import { ethers } from 'ethers'
import { Session, SessionSettings } from '@0xsequence/auth'

...

const getBlockNumber = async (chainId: string, request: Request): Promise<number> => {
	const nodeUrl = `https://nodes.sequence.app/${chainId}`
	const provider = new ethers.providers.JsonRpcProvider({ url: nodeUrl, skipFetchSetup: true })
	return await provider.getBlockNumber()
}

const callContract = async (request: Request, env: Env, address: string, tokenId: number): Promise<ethers.providers.TransactionResponse> => {

	const nodeUrl = `https://nodes.sequence.app/${env.CHAIN_HANDLE}`
	const relayerUrl = `https://${env.CHAIN_HANDLE}-relayer.sequence.app`
	const contractAddress = env.CONTRACT_ADDRESS


	// instantiate settings
	const settings: Partial<SessionSettings> = {
		networks: [{
			...networks[findSupportedNetwork(env.CHAIN_HANDLE)!.chainId],
			rpcUrl: findSupportedNetwork(env.CHAIN_HANDLE)!.rpcUrl,
			relayer: {
				url: relayerUrl,
				provider: {
					url: findSupportedNetwork(env.CHAIN_HANDLE)!.rpcUrl
				}
			}
		}],
	}

    // create a single signer sequence wallet session
	const session = await Session.singleSigner({
		settings: settings,
		signer: env.PKEY,
		projectAccessKey: env.PROJECT_ACCESS_KEY
	})

	// get signer
	const signer = session.account.getSigner(findSupportedNetwork(env.CHAIN_HANDLE)!.chainId)

	// create interface from partial abi
	const collectibleInterface = new ethers.Interface([
		'function mint(address to, uint256 tokenId, uint256 amount, bytes data)'
	])

	// create calldata
	const data = collectibleInterface.encodeFunctionData(
		'mint', [address, tokenId, 1, "0x00"]
	)

	// create transaction object
	const txn = { to: contractAddress, data }

	try {
		return await signer.sendTransaction(txn)
	} catch (err) {
		throw err
	}
}
```

これらの手順が完了したら、[前のステップ](/guides/mint-collectibles-serverless#testing)で説明した手順で再デプロイしてテストできます。今回はPOSTリクエストが完了したミントのトランザクションハッシュを返し、GETリクエストはブロック番号を返すはずです。

完全なコードを閲覧したい場合は、[こちらの実装例をご覧ください](https://github.com/0xsequence-demos/cloudflare-worker-sequence-transactions-api)
