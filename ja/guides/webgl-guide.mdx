---
title: WebGLを使用したAviator Web3ゲーム
description: Sequence Stackのツールを使用してWebGLをゲームに統合し、
  実績を獲得してカスタムERC1155を使用する方法を学びます。
sidebarTitle: WebGLでゲームを構築する
---

所要時間: 40分

このガイドでは、WebGLをゲームに統合し、Sequence Stackのツールを活用して実績を獲得し、カスタムERC1155をゲーム内で使用するプロセスを説明します。

<Note>
  ゲームのライブバージョンは[こちら](https://0xsequence.github.io/aviator-demo/)

  このゲームの完全なコードは[こちら](https://github.com/0xsequence/aviator-demo/)

  そして、このガイドで使用する完全なテンプレートコードは[こちら](https://github.com/0xsequence-demos/template-webgl-js-sequence-kit-starter)
</Note>

これらのツールで以下のことが可能になります：

1. [Webpackでのプロジェクトセットアップ](/guides/webgl-guide#1-project-setup-with-webpack)：WebpackでコンパイルできるWebGLを使用したプロジェクト構造を有効にする
2. [Web SDKの統合](/guides/webgl-guide#2-integrate-sequence-kit)：すべてのEOAとSequence Walletでユーザー認証を可能にする
3. [コレクティブルコントラクトのデプロイ](/guides/webgl-guide#3-deploy-a-collectibles-contract)：独自のコレクティブルコントラクトを作成
4. [リモートミンターのデプロイとゲーム内トークンのミント](/guides/webgl-guide#4-deploy-a-remote-minter-and-mint-in-game-achievement-tokens)：Cloudflareワーカーでガスレスのリレートランザクションを実行
5. [ゲーム内でのアイテムの活用](/guides/webgl-guide#5-leverage-items-in-game)：Sequence Indexerを使用してゲーム内でコレクティブルを統合
6. [ゲーム内実績トークンのバーン](/guides/webgl-guide#6-burn-in-game-achievement-tokens)：wagmiでゲーム実績をバーン
7. [（オプション）Web SDKへの組み込みウォレットの統合](/guides/webgl-guide#7-optional-integrate-embedded-wallet-into-sequence-kit)：署名者の署名メッセージを使用せずにスムーズなUXを実現

## 1. Webpackでのプロジェクトセットアップ

#### リポジトリのクローン

まず、テンプレートプロジェクトをクローンします。このプロジェクトには`three`を使用して作成されたいくつかのWebGLベースのコンポーネントが含まれており、すべて[webpack](https://webpack.js.org/)

[Template WebGL JS Web SDK Starter](https://github.com/0xsequence-demos/template-webgl-js-sequence-kit-starter/tree/simple-start)

上記のリポジトリをクローンし、`cd`でリポジトリに移動します`cd template-webgl-js-sequence-kit-starter`

#### 更新`.env`

以下の環境変数を含む`.env`ファイルを作成します`.env.example`を使用して

```
PROJECT_ACCESS_KEY=
WALLET_CONNECT_ID=
```

そして、アプリを実行するために以下のコマンドを実行します

```
# or your choice of package manager
pnpm install
pnpm run dev
```

素晴らしい、水上を飛行する飛行機が表示されるはずです

## 2. Web SDKの統合

プロジェクト構造のセットアップが完了したので、Web SDKを統合できます

#### セットアップ`App.jsx`コンポーネント

フォルダ内に`src`という名前のフォルダを作成し、`react`2つのファイルを作成します：`App.jsx`と`Login.jsx`

ファイル`App.jsx`に以下のコードを含めます

```js
import React from "react";
import { useOpenConnectModal } from "@0xsequence/kit";
import { useDisconnect, useAccount } from "wagmi";
import Login from "./Login.jsx";

import { KitProvider } from "@0xsequence/kit";
import { getDefaultConnectors } from "@0xsequence/kit-connectors";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { createConfig, http, WagmiConfig } from "wagmi";
import { arbitrumSepolia, Chain } from "wagmi/chains";

const queryClient = new QueryClient();

function App(props) {
  const chains = [arbitrumSepolia];
  const projectAccessKey = process.env.PROJECT_ACCESS_KEY;

  const connectors = getDefaultConnectors("universal", {
    walletConnectProjectId: process.env.WALLET_CONNECT_ID,
    defaultChainId: 421614,
    appName: "demo app",
    projectAccessKey,
  });

  const transports = {};

  chains.forEach((chain) => {
    transports[chain.id] = http();
  });

  const config = createConfig({
    transports,
    connectors,
    chains,
  });

  return (
    <WagmiConfig config={config}>
      <QueryClientProvider client={queryClient}>
        <KitProvider config={{ defaultTheme: "dark" }}>
          <Login scene={props.scene} />
        </KitProvider>
      </QueryClientProvider>
    </WagmiConfig>
  );
}

export default App;
```

次に、`Login.jsx`ファイルに以下のコードを追加して、画面上部にアプリケーションにログインするためのボタンを作成します

```js
import React, { useEffect } from "react";
import { useOpenConnectModal, useKitWallets } from "@0xsequence/kit";
import { useWalletClient } from "wagmi";

function Login(props) {
  const { setOpenConnectModal } = useOpenConnectModal();
  const { data: walletClient } = useWalletClient();
  const {
    wallets, // Array of connected wallets
    linkedWallets, // Array of linked wallets (for embedded wallets)
    setActiveWallet, // Function to set a wallet as active
    disconnectWallet, // Function to disconnect a wallet
  } = useKitWallets();

  const isConnected = wallets.length;

  useEffect(() => {
    if (isConnected) {
      props.scene.login();
    } else {
      props.scene.logout();
    }
  }, [isConnected]);

  const sendBurnToken = async () => {
    // empty for now
  };

  useEffect(() => {
    if (isConnected && walletClient) {
      props.scene.sequenceController.init(walletClient, sendBurnToken);
    }
  }, [isConnected, walletClient]);

  return (
    <>
      <div style={{ textAlign: "center" }}>
        <br />
        {isConnected && (
          <div
            onClick={() => disconnectWallet(wallets[0].address) // assuming one wallet is connected. you can also disconnect a specific wallet from useKitWallets by specifying the address}
            style={{
              cursor: "pointer",
              position: "fixed",
              top: "30px",
              right: "30px",
              zIndex: "1",
            }}
          >
            sign out
          </div>
        )}
      </div>
    </>
  );
}

export default Login;
```

#### JavaScriptでコンポーネントをレンダリング`index.js`

最後に、`index.js`に`App.jsx`コンポーネントをインポートし、`root`ID要素に追加するようにレンダリングします`index.html`

```js
import * as ReactDOM from 'react-dom/client';
import App from './react/App.jsx'

...

const root = ReactDOM.createRoot(document.getElementById('root'))

root.render(
    <App scene={mainScene}/>
);
```

##### ログインモーダルを呼び出すクリックハンドラーの作成

以下のコードを`Login.jsx`コンポーネントに追加します

```js
window.setOpenConnectModal = () => {
  setOpenConnectModal(true);
};
```

そして以下のクリックハンドラーコードを`index.js`

```ts
function handleMouseUp(event) {
  window.setOpenConnectModal();
}

document
  .getElementById("world")
  .addEventListener("mouseup", handleMouseUp, false);
```

そしてこれらの要素を`index.html`

```html
<div id="mintBtn" className="btn" onclick="window.mintPlane()">mint plane</div>
<div id="mintAchievementBtn" className="btn" onclick="window.mintAchievement()">
  mint achievement
</div>
<div id="burnBtn" className="btn" onclick="window.burn()">burn achievement</div>

<div id="login">click to login</div>
<div className="world" id="world"></div>
```

素晴らしい、これでモーダルを表示するボタンができました

## 3. コレクティブルコントラクトのデプロイ

以下の[Sequence Builder](https://sequence.build)からコレクティブルを作成する必要があります。これは[ガイド](/solutions/collectibles/contracts/deploy-an-item-collection)

2つのコレクションを作成する必要があります：1つは実績トークン用、もう1つは飛行機用です

## 4. リモートミンターのデプロイとゲーム内実績トークンのミント

次に、ガスレスでシームレスにブロックチェーンにトランザクションを送信するために、[Cloudflare Worker](/guides/mint-collectibles-serverless)を実装して、前のステップでデプロイしたコントラクトからアイテムをミントします。トランザクションAPIコントラクトアドレスが`Minter Role`

コレクティブルをミントする複数のパスを許可します：飛行機コレクティブルと実績コレクティブルです。

これはコードで`isPlane`をCloudflareリクエストボディに追加し、`if/else`をCloudflareワーカーに作成することで実現されます。

このコードは[githubリポジトリ](https://github.com/0xsequence-demos/template-webgl-js-sequence-kit-starter/blob/master/cloudflare/noisy-silence-ee19/src/index.ts#L80)

このガイドでは、すべてのCloudflareコードをローカル開発環境で実行します。これは、名前付きプロジェクトフォルダでCloudflareワーカーを以下のように起動することで実現できます：

```
wrangler dev
```

## 5. ゲーム内でのアイテムの活用

このセクションは、ゲーム内資産の所有権変更に基づくUIの更新の2つの実装に分かれています：

* ウォレット資産に基づく飛行機の変更の表示
* ウォレット資産に基づくUI変更の表示

#### ウォレット資産に基づく機体の変更表示

ウォレット資産の所有状況に基づいてゲームに変更を実装するには、トークンをミントするボタンを実装し、レスポンスでインデクサーの変更を確認することができます

この`index.js`では、index.htmlの`onclick`属性に付加されたボタンを含めます

```js
window.mintPlane = () => {
  const tokenID = 1;
  mainScene.sequenceController.callContract(tokenID, true, (res) => {
    mainScene.sequenceController.fetchPlaneTokens(tokenID);
  });
};
```

ここで`callContract`は、クリックの連打を防ぐために、一度に1つのミントが行われることを保証するミューテックスでラップされたフェッチを呼び出すことでミントを処理し、`SequenceController`クラスの`/API/SequenceController.js`

```js
import { Mutex, E_CANCELED} from 'async-mutex';

const mutexMinting = new Mutex();
...
async callContract(tokenId, isPlane, callback) {
  if(!mutexMinting.isLocked()){
    try {
      await mutexMinting.runExclusive(async () => {
        console.log('Minting token:', tokenId);
        const url = 'http://localhost:8787';
        const data = {
          address: this.walletAddress,
          tokenId: tokenId,
          isPlane: isPlane
        };

        try {
          const res = await fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(data),
          })
          const txHash = await res.text();
          mutexMinting.release();
          callback(txHash);
        } catch(err) {
          mutexMinting.release();
          callback(err);
        }
      });
    } catch (err) {
      if (err === E_CANCELED) {
        mutexMinting.release();
      }
    }
  } else {
    console.log('mutex is locked')
  }
}
```

そして`fetchPlaneTokens`は、ウォレットにアセットが入るまで結果をポーリングし、`plane color`を異なる機体を表すように更新します。

`fetchPlaneTokens`は、残高の条件チェックが1より大きく、`tokenID`が検索対象のIDと等しい場合に実装されます。

このUI条件ロジックはアプリケーションに応じて変更されます

```js
import { SequenceIndexer } from '@0xsequence/indexer';
...
async fetchPlaneTokens(){

  // a polling wait
  const wait = (ms) => new Promise((res) => setTimeout(res, ms))
  let hasFoundPlane = false

  while(!hasFoundPlane) {
      const response = await this.indexer.getTokenBalances({
      accountAddress: this.walletAddress,
      contractAddress: '0x10ac72ada55ed46ee35deed371b8d215c2e870e1', // the collection address
    })
    await wait(1000)
    for(let i = 0; i < response.balances.length; i++){
      // a check on the inventory
      if(response.balances[i].tokenID == '1' && Number(response.balances[i].balance) > 0){
        // implement any UI update here
        this.scene.airplane.addPlane(Number(response.balances[i].tokenID))
        hasFoundPlane = true // breaks from the loop
      }
    }
  }
}
```

#### ウォレット資産に基づくUI変更の表示

次に、ユーザーが実績を持っているかどうかに基づいて`burn achievement`ボタンを追加するUI変更を実装します

まず、前回と同様のHTML/JSクリックハンドラーロジックを実装します

今回は、`isPlane`の値`callContract`に設定されます`false`

```js
// index.js
window.mintAchievement = () => {
  const tokenID = 0;
  mainScene.sequenceController.callContract(tokenID, false, (res) => {
    mainScene.sequenceController.fetchTokensFromAchievementMint(tokenID);
  });
};
```

<Warning>
  注意：実際のゲームでは、この実績トークンのミントはゲーム内の何らかのトリガーイベントに基づいて行われますが、簡単のためにボタンを含めています
</Warning>

今回は、`fetchTokensFromAchievementMint`を呼び出します。これは`SequenceController`

```js
  async fetchTokensFromAchievementMint(tokenID) {
    // check for achievement balance
    const wait = (ms) => new Promise((res) => setTimeout(res, ms))
    let hasFoundPlane = false
    let tokenIDs = []
    while(!hasFoundPlane) {
      const response = await this.indexer.getTokenBalances({
        accountAddress: this.walletAddress,
        contractAddress: '0x856de99d7647fb7f1d0f60a04c08340db3875340', // you achievements collection address
      })
      await wait(1000)
      for(let i = 0; i < response.balances.length; i++){
        // can update this logic to see if there is any balance: i.e. if(response.balances.length > 0)
        if(response.balances[i].tokenID == String(tokenID)){
          hasFoundPlane = true
          // making the button appear
          document.getElementById('burnBtn').style.display = 'flex'
        }
      }
    }
  }
```

これにより、インデクサーから残高が返された場合にのみ、`display`属性によってボタンが表示されます

## 6. ゲーム内実績トークンの焼却

最後に、実績トークンを焼却するために、ブロックチェーンに送信されるアクションにCloudflare Workerを使用することはできなくなります。これは、ミントがトランザクションAPI（コントラクトの`msg.sender`を`relayer`アドレスの1つにする）を使用してアドレスの「代わりに」実行されたためです。このため、`msg.sender`がコントラクトでトークンの所有権を証明し、`user`から直接送信されることを確認する必要があります。`wagmi`フロントエンド関数とクラスコンポジションを使用してこれを実現します。

```js
// index.js
window.burn = () => {
  const tokenID = 0;
  mainScene.sequenceController.burnToken(tokenID, (res) => {
    mainScene.sequenceController.fetchTokensFromBurn(tokenID);
  });
};
```

ここで`burnToken`はReactコンポーネントから渡された関数で、ミューテックスを使用する同様のパターンを使用し、`sendTransaction`を使用して`wagmi`パッケージからトランザクションを送信し、トランザクションハッシュの更新を待ってコールバックを返します

```js
// react/Login.jsx
import {
    useAccount,
    useWalletClient,
    useSendTransaction,
} from 'wagmi';
import { useMutex } from 'react-context-mutex';
import { ethers } from 'ethers'
import { SequenceIndexer } from '@0xsequence/indexer';

let burnCallback = null
const ContractAddress = '0x856de99d7647fb7f1d0f60a04c08340db3875340';

function Login() {
  const MutexRunner = useMutex();
  const mutexBurn = new MutexRunner('sendMutexBurn');

  const { isConnected } = useAccount()
  const { data: walletClient } = useWalletClient();
  const { data: txnData, sendTransaction, isLoading: isSendTxnLoading } = useSendTransaction();

  useEffect(() => {
    if (isConnected && walletClient) {
        props.scene.sequenceController.init(
            walletClient,
            sendBurnToken
        );
    }
  }, [isConnected, walletClient]);

  const sendBurnToken = async (tokenID, callback) => {
      if(!mutexBurn.isLocked()){
          const contractABI = ['function burn(uint256 tokenId, uint256 amount)']; // Replace with your contract's ABI
          const contract = new ethers.Contract(ContractAddress, contractABI);

          // call indexer
          // check for achievement balance
          const indexer = new SequenceIndexer(
              'https://arbitrum-sepolia-indexer.sequence.app',
              process.env.PROJECT_ACCESS_KEY
          );

          const response = await indexer.getTokenBalances({
              accountAddress: walletClient.account.address,
              contractAddress: '0x856de99d7647fb7f1d0f60a04c08340db3875340',
          })

          const data = contract.interface.encodeFunctionData('burn', [
              tokenID,
              response.balances[0].balance, // get the balance from the indexer
          ]);

          try {
              mutexBurn.lock()
              burnCallback = callback
              await sendTransaction({
                  to: ContractAddress,
                  data: data,
                  value: '0',
                  gas: null,
              })
          } catch (error) {
              console.log(error)
          callback(error);
          }
      } else {
          console.log('burn in progress')
      }
  };

  useEffect(() => {
    if(txnData && burnCallback && mutexBurn.isLocked()) {
        mutexBurn.unlock();
        burnCallback(txnData)
    }
  }, [burnCallback, txnData])
...
}
```

そして`SequenceController`で、`sendBurnToken`関数を`burnToken`でラップして、React関数をアプリケーションの他の部分からアクセス可能にします

```js
async burnToken(tokenID, callback) {
  this.sendBurnToken(tokenID, callback);
}

async init(walletClient, sendTransactionBurn) {
  this.walletAddress = walletClient.account.address;

  this.sendBurnToken = sendTransactionBurn;
}
```

次に、焼却されたトークンがUIに影響を与えるようにするために、最初の場所でトークンを焼却するために使用したボタンを非表示にします。これは`SequenceController`

```js
async fetchTokensFromBurn(tokenID){
  const wait = (ms) => new Promise((res) => setTimeout(res, ms))
  let hasBeenBurned = false
  while(!hasBeenBurned) {
    let tokenIDs = [] // create an empty array to include all the tokens
    const response = await this.indexer.getTokenBalances({
      accountAddress: this.walletAddress,
      contractAddress: '0x856de99d7647fb7f1d0f60a04c08340db3875340',
    })
    await wait(1000)
    for(let i = 0; i < response.balances.length; i++){
        tokenIDs.push(response.balances[i].tokenID)
    }
    if(!tokenIDs.includes(String(tokenID))) { // check that the token id is not contained in the array
      hasBeenBurned = true
      // can apply any UI logic here
      document.getElementById('burnBtn').style.display = 'none' // hide the button
    }
  }
}
```

これで完了です。コードの完全な例は[こちら](https://github.com/0xsequence-demos/template-webgl-js-sequence-kit-starter)

## 7. （オプション）Web SDKへの組み込みウォレットの統合

ユーザーのトランザクション署名を全体的に不要にしてユーザージャーニーをスムーズにしたい場合は、Web SDK Reactコンポーネントの設定を更新して組み込みウォレットを有効にすることができます。

これを実現することで、`wagmi`でトークンを焼却する際のポップアップを削減できます。実績トークンの付与とコレクティブルのミントは、ガスレストランザクション用のCloudflare Workerを使用して完了するためです。

これは、いくつかの環境変数を追加し、使用するコネクタの種類を切り替えることで実現できます。

まず、`.env`ファイルを以下の環境シークレットで更新します

```
WAAS_CONFIG_KEY=
GOOGLE_CLIENT_ID=
APPLE_CLIENT_ID=
```

次に、これらの変数を`App.jsx`

```js

import { getKitConnectWallets } from '@0xsequence/kit';
import { getDefaultWaasConnectors } from '@0xsequence/kit-connectors';
import { createConfig, http, WagmiProvider } from 'wagmi';
...
const projectAccessKey = process.env.PROJECT_ACCESS_KEY_NEXT;
const waasConfigKey = process.env.WAAS_CONFIG_KEY;
const googleClientId = process.env.GOOGLE_CLIENT_ID;
const appleClientId = process.env.APPLE_CLIENT_ID;

function App(props) {

  const appleRedirectURI =
  'https://' + window.location.host + '/aviator-demo';

  const connectors = [
    ...getDefaultWaasConnectors({
      walletConnectProjectId: process.env.WALLET_CONNECT_ID,
      defaultChainId: 421614,
      waasConfigKey,
      googleClientId,
      appleClientId,
      appleRedirectURI,
      appName: 'demo app',
      projectAccessKey,
      enableConfirmationModal: false,
    }),
    ...getKitConnectWallets(projectAccessKey, []),
  ];

  const transports = {};

  chains.forEach(chain => {
    transports[chain.id] = http();
  });

  const config = createConfig({
    transports,
    connectors,
    chains,
  });

  return (
    <WagmiProvider config={config}>
    ...
    <WagmiProvider/>
  )
}
```

これで完了です。トランザクションフローを完了させるためのさらなる統合は必要ありません

<Note>
  ゲーム内ウォレットについて詳しく学ぶには、
  [こちら](/solutions/wallets/embedded-wallet/overview)
</Note>
