---
title: 署名エンコーディング
description: Sequence Walletsは、トランザクションとメッセージの署名のためにERC-1271標準コントラクト署名検証をサポートしています。メッセージはERC-191 Ethereum署名データまたはERC-712構造化データ署名でエンコードできます。
sidebarTitle: 署名エンコーディング
---

Sequence Walletsは[ERC-1271標準コントラクト署名検証](https://eips.ethereum.org/EIPS/eip-1271)でトランザクションとメッセージの署名を可能にします。

## ERC-191 Ethereum署名データ

以下のようにエンコードされたメッセージは[ERC-191 Ethereum署名データ](https://eips.ethereum.org/EIPS/eip-191)として作成および署名することができます。

```ts
import { Wallet } from '@0xsequence/wallet'

// Construct your Sequence Wallet (out of scope for this section)
const wallet: Wallet

const message = "Hello, World!"

const prefixedMessage = "\x19Ethereum Signed Message:\n" + len(message) + message
const signature = await wallet.signMessage(prefixedMessage)
```

上記はローカルを反復処理し、メッセージに署名します。閾値に達した場合、署名が返されます。
そうでない場合、ライブラリはリモート署名者も反復処理します。
結果の署名は結合され、16進数文字列としてエンコードされます。

## ERC-712構造化データ署名

[ERC-712構造化データ](https://eips.ethereum.org/EIPS/eip-712)も同様の方法で署名することができます。

```ts
import { Wallet } from '@0xsequence/wallet'
import { encodeTypedDataDigest } from '@0xsequence/utils'

// Construct your Sequence Wallet (out of scope for this section)
const wallet: Wallet

// Encode the typed data
const chainId = 1
const typedData = {
	types: {
		Person: [
			{ name: 'name', type: 'string' },
			{ name: 'wallet', type: 'address' },
			{ name: 'count', type: 'uint8' }
		]
	},
	primaryType: 'Person' as const,
	domain: {
		name: 'Ether Mail',
		version: '1',
		chainId: chainId,
		verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC'
	},
	message: {
		name: 'Bob',
		wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
		count: 4
	}
} 
const hashedData = encodeTypedDataDigest(typedData)

const signature = await wallet.signMessage(hashedData)
```

上記はローカルを反復処理し、メッセージに署名します。閾値に達した場合、署名が返されます。
そうでない場合、ライブラリはリモート署名者も反復処理します。
結果の署名は結合され、16進数文字列としてエンコードされます。

## 検証

署名は、ウォレットの`isValidSignature`メソッドを呼び出すことで検証できます。

```
  /**
   * @notice Verifies whether the provided signature is valid with respect to the provided hash
   * @dev MUST return the correct magic value if the signature provided is valid for the provided hash
   *   > The bytes4 magic value to return when signature is valid is 0x1626ba7e : bytes4(keccak256("isValidSignature(bytes32,bytes)"))
   * @param _hash       keccak256 hash that was signed
   * @param _signatures Signature byte array associated with _data.
   *                    Encoded as abi.encode(Signature[], Configs)
   * @return magicValue Magic value 0x1626ba7e if the signature is valid and 0x0 otherwise
   */
  function isValidSignature(
    bytes32 _hash,
    bytes calldata _signatures
  ) public override virtual view returns (bytes4) {
    // Validate signatures
    (bool isValid,) = _signatureValidation(_hash, _signatures);
    if (isValid) {
      return SELECTOR_ERC1271_BYTES32_BYTES;
    }

    return bytes4(0);
  }
```

これは結合された署名を反復処理し、結果の署名がウォレットの閾値を超えていることを検証します。
