---
title: メッセージの署名と検証
description: Sequence ウォレットを使用してメッセージを署名および検証する方法について詳しい説明を提供します。
---

## メッセージの署名

Sequence ウォレットは任意のメッセージに署名することができます。

**単純なメッセージへのユーザーの署名をリクエストするには：**

```ts
const signer = wallet.getSigner();
const message = "Hello World!";

const signature = await signer.signMessage(message);
console.log(signature);
```

**型付きデータ（[EIP712](https://eips.ethereum.org/EIPS/eip-712)）メッセージへのユーザーの署名をリクエストするには：**

```ts
const typedData: sequence.utils.TypedData = {
  domain: {
    name: "Ether Mail",
    version: "1",
    chainId: await wallet.getChainId(),
    verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
  },
  types: {
    Person: [
      { name: "name", type: "string" },
      { name: "wallet", type: "address" },
    ],
  },
  message: {
    name: "Bob",
    wallet: "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB",
  },
};

const signer = wallet.getSigner();

const signature = await signer.signTypedData(
  typedData.domain,
  typedData.types,
  typedData.message
);
console.log(signature);
```

<br />

## メッセージ署名の検証

署名を取得したら、アプリケーションまたはサーバーからデータの有効性を検証したい場合が多くあります。Sequence SDKsを使用すると、フロントエンドまたはバックエンドのどちらからでも簡単に検証することができます。

メッセージと署名が与えられた場合、特定のウォレットがそのメッセージに署名したかどうかを確認できます：

```ts
// Here we fetch the different parameters, but in practice you may have these values
// encoded and passed separately.
const wallet = sequence.getWallet();
const provider = wallet.getProvider();
const walletAddress = wallet.getAddress();
const chainId = wallet.getChainId();

// The sequence utils `isValidMessageSignature` method can validate signatures
// from any kind of wallet (ie. EOA or Smart Wallet) which includes Metamask, Coinbase,
// and Sequence.
const isValid = await wallet.utils.isValidMessageSignature(
  walletAddress,
  message,
  signature,
  chainId
);

console.log(isValid);
```

<Info>
  Sequence はスマートコントラクトベースのアカウントです
  これらの署名はデフォルトでEIP-6492を使用してエンコードされます。参照：[https://eips.ethereum.org/EIPS/eip-6492](https://eips.ethereum.org/EIPS/eip-6492).

  これは、署名がEIP-6492で定義された標準プロセスを使用して検証できることを意味します`UniversalVerified`コントラクト上で。

  この`wallet.utils.isValidMessageSignature`はEIP-6492検証を実装しており、あらゆる種類のウォレットからの署名を検証するために使用できます。
</Info>

<br />

## メッセージ署名の検証（Sequence APIを介して）

<Warning>
  非EIP6492署名の署名にはウォレットがオンチェーンにデプロイされている必要があることに注意してください。そのため、メッセージに署名する前にウォレットをオンチェーンにデプロイするようユーザーに促されます。ネットワークに手数料がある場合（Ethereumなど）、ユーザーはトランザクション手数料の支払いも求められます。
</Warning>

<Warning type="danger">
  SEQUENCE BUILDERの紹介 - [https://sequence.build](https://sequence.build)

  私たちのAPIサービスは現&#x5728;**[Sequence Builder](https://sequence.build)**&#x3092;通じて管理されています。サインアップしてAPIアクセスキーを取得してください。

  [今すぐ**Sequence Builder**の無料プランを始めましょう！](https://sequence.build)
</Warning>

Sequence APIは、シンプルなリモートAPIコールを行うことで、任意のウォレットメッセージ署名を検証する便利な機能も提供しています。

Sequence API（[https://api.sequence.app](https://api.sequence.app)）は以下のRPCメソッドをサポートしています：

* `/rpc/API/IsValidMessageSignature` -- 単純なテキストメッセージ署名の検証
* `/rpc/API/IsValidTypedDataSignature` -- EIP712型付きデータオブジェクトの検証
* `/rpc/API/IsValidSignature` -- 任意のメッセージダイジェストの検証
* `/rpc/API/IsValidETHAuthProof` -- [ETHAuth](https://github.com/0xsequence/ethauth.js)プルーフの検証

最も一般的なメソッドは`IsValidMessageSignature`と`IsValidETHAuthProof`です。

### あらゆる種類のウォレット（MetamaskやSequenceなど）からのメッセージ署名の検証

*Sequence API `IsValidMessageSignature`メソッド：*

* リクエスト: POST [https://api.sequence.app/rpc/API/IsValidMessageSignature](https://api.sequence.app/rpc/API/IsValidMessageSignature)
* Content-Type: application/json
* ボディ（JSON形式）：
  * `chainId`（文字列） -- 署名のチェーンID、例："1"または"mainnet"、"137"または"polygon"など
  * `walletAddress`（文字列） -- ウォレットアドレス
  * `message`（文字列） -- UTF8テキストエンコーディングのメッセージ
  * `signature`（文字列） -- 16進数エンコーディングの署名

<br />

**`IsValidMessageSignature`使用例：**

<CodeGroup>
  ```shell twoslash [cURL]
  curl -X POST -H "Content-Type: application/json" https://api.sequence.app/rpc/API/IsValidMessageSignature -d '{ "chainId": "polygon", "walletAddress": "0x2fa0b551fdFa31a4471c1C52206fdb448ad997d1", "message": "Hi, please sign this message", "signature": "0x000501032a44625bec3b842df681db00a92a74dda5e42bcf0203596af90cecdbf9a768886e771178fd5561dd27ab005d0001000183d971056b1eca1bcc7289b9a6926677c5b07db4197925346367f61f2d09c732760719a91722acee0b24826f412cb69bd2125e48f231705a5be33d1f5523f9291c020101c50adeadb7fe15bee45dcb820610cdedcd314eb0030002f19915df00d669708608502d3011a09948b32674d6e443202a2ba884a4dcd26c2624ff33a8ee9836cc3ca2fbb8d3aa43382047b73d21646cb66cc2916076c1331c02" }'
  ```

  ```js twoslash [TypeScript]
  // Works in both a Webapp (browser) or Node.js:
  import { sequence } from "0xsequence";

  const chainId = "polygon";
  const walletAddress = "0x2fa0b551fdFa31a4471c1C52206fdb448ad997d1";
  const message = "Hi, please sign this message";
  const signature =
    "0x000501032a44625bec3b842df681db00a92a74dda5e42bcf0203596af90cecdbf9a768886e771178fd5561dd27ab005d0001000183d971056b1eca1bcc7289b9a6926677c5b07db4197925346367f61f2d09c732760719a91722acee0b24826f412cb69bd2125e48f231705a5be33d1f5523f9291c020101c50adeadb7fe15bee45dcb820610cdedcd314eb0030002f19915df00d669708608502d3011a09948b32674d6e443202a2ba884a4dcd26c2624ff33a8ee9836cc3ca2fbb8d3aa43382047b73d21646cb66cc2916076c1331c02";

  const api = new sequence.api.SequenceAPIClient("https://api.sequence.app");
  const { isValid } = await api.isValidMessageSignature({
    chainId,
    walletAddress,
    message,
    signature,
  });
  console.log(isValid); // true
  ```

  ```go twoslash [go]
  import (
  	"context"
  	"fmt"
  	"log"
  	"net/http"

  	"github.com/0xsequence/go-sequence/api"
  )

  func ValidateMessageSignature() {
  	seqAPI := api.NewAPIClient("https://api.sequence.app", http.DefaultClient)

  	chainID := "polygon"
  	walletAddress := "0x2fa0b551fdFa31a4471c1C52206fdb448ad997d1"

  	// NOTE: you can also pass the message in EIP191 format as well. If you do not pass
  	// the EIP191 prefix, it will automatically be added at the time of validation.
  	// message := fmt.Sprintf("\x19Ethereum Signed Message:\n%d%s", len(message), message)
  	message := "Hi, please sign this message"

  	signature := "0x000501032a44625bec3b842df681db00a92a74dda5e42bcf0203596af90cecdbf9a768886e771178fd5561dd27ab005d0001000183d971056b1eca1bcc7289b9a6926677c5b07db4197925346367f61f2d09c732760719a91722acee0b24826f412cb69bd2125e48f231705a5be33d1f5523f9291c020101c50adeadb7fe15bee45dcb820610cdedcd314eb0030002f19915df00d669708608502d3011a09948b32674d6e443202a2ba884a4dcd26c2624ff33a8ee9836cc3ca2fbb8d3aa43382047b73d21646cb66cc2916076c1331c02"

  	isValid, err := seqAPI.IsValidMessageSignature(context.Background(), chainID, walletAddress, message, signature)
  	if err != nil {
  		log.Fatal(err)
  	}
  	fmt.Println("isValid?", isValid)
  }
  ```

  ```shell twoslash [other]
    Please contact our team for assistance with integrations to another target.
  ```
</CodeGroup>

<br />

### Sequence Walletの接続時のETHAuthプルーフの検証

*Sequence API `IsValidETHAuthProof`メソッド：*

* リクエスト: POST [https://api.sequence.app/rpc/API/IsValidETHAuthProof](https://api.sequence.app/rpc/API/IsValidETHAuthProof)
* Content-Type: application/json
* ボディ（JSON形式）：
  * `chainId`（文字列） -- 署名のチェーンID、例："1"または"mainnet"、"137"または"polygon"など
  * `walletAddress`（文字列） -- ウォレットアドレス
  * `ethAuthProofString`（文字列） -- ETHAuthエンコードされた署名

<br />

**`IsValidETHAuthProof`使用例：**

<CodeGroup>
  ```shell twoslash [cURL]
  curl -X POST -H "Content-Type: application/json" https://api.sequence.app/rpc/API/IsValidETHAuthProof -d '{"chainId":"polygon", "walletAddress":"0x2fa0b551fdFa31a4471c1C52206fdb448ad997d1","ethAuthProofString": "eth.0x2fa0b551fdfa31a4471c1c52206fdb448ad997d1.eyJhcHAiOiJEZW1vIERhcHAiLCJpYXQiOjAsImV4cCI6MTY2MDIzMTAyOCwidiI6IjEiLCJvZ24iOiJodHRwOi8vbG9jYWxob3N0OjQwMDAifQ.0x000501032a44625bec3b842df681db00a92a74dda5e42bcf0203596af90cecdbf9a768886e771178fd5561dd27ab005d00010001f7dad5ade840bb961cbab889d731bbc080bb4c36fc090435e82fe78e3c152b671505ad544adb562cc25a5933cd06c9108e239a52a82ba797c3d3522645c69cd81b020101c50adeadb7fe15bee45dcb820610cdedcd314eb003000274164fb33c93b4384582c54c30d9a1e2ef219063d03084005edc1da853af2f1f2e67275dbb6ef945d04600b6dd83cfd997cc9ae4173ea61b0c5cc0808fb196681b02"}' 
  ```

  ```js twoslash [TypeScript]
  // Works in both a Webapp (browser) or Node.js:
  import { sequence } from "0xsequence";

  const chainId = "polygon";
  const walletAddress = "0x2fa0b551fdFa31a4471c1C52206fdb448ad997d1";
  const ethAuthProofString =
    "eth.0x2fa0b551fdfa31a4471c1c52206fdb448ad997d1.eyJhcHAiOiJEZW1vIERhcHAiLCJpYXQiOjAsImV4cCI6MTY2MDIzMTAyOCwidiI6IjEiLCJvZ24iOiJodHRwOi8vbG9jYWxob3N0OjQwMDAifQ.0x000501032a44625bec3b842df681db00a92a74dda5e42bcf0203596af90cecdbf9a768886e771178fd5561dd27ab005d00010001f7dad5ade840bb961cbab889d731bbc080bb4c36fc090435e82fe78e3c152b671505ad544adb562cc25a5933cd06c9108e239a52a82ba797c3d3522645c69cd81b020101c50adeadb7fe15bee45dcb820610cdedcd314eb003000274164fb33c93b4384582c54c30d9a1e2ef219063d03084005edc1da853af2f1f2e67275dbb6ef945d04600b6dd83cfd997cc9ae4173ea61b0c5cc0808fb196681b02";

  const api = new sequence.api.SequenceAPIClient("https://api.sequence.app");
  const { isValid } = await api.isValidETHAuthProof({
    chainId: chainId,
    walletAddress: walletAddress,
    ethAuthProofString: ethAuthProofString,
  });
  console.log(isValid); // true
  ```

  ```go twoslash [go]
  import (
  	"context"
  	"fmt"
  	"log"
  	"net/http"

  	"github.com/0xsequence/go-sequence/api"
  )

  func ValidateETHAuth() {
  	seqAPI := api.NewAPIClient("https://api.sequence.app", http.DefaultClient)

  	chainID := "polygon"
  	walletAddress := "0x2fa0b551fdFa31a4471c1C52206fdb448ad997d1"
  	ethAuthProofString := "eth.0x2fa0b551fdfa31a4471c1c52206fdb448ad997d1.eyJhcHAiOiJEZW1vIERhcHAiLCJpYXQiOjAsImV4cCI6MTY2MDIzMTAyOCwidiI6IjEiLCJvZ24iOiJodHRwOi8vbG9jYWxob3N0OjQwMDAifQ.0x000501032a44625bec3b842df681db00a92a74dda5e42bcf0203596af90cecdbf9a768886e771178fd5561dd27ab005d00010001f7dad5ade840bb961cbab889d731bbc080bb4c36fc090435e82fe78e3c152b671505ad544adb562cc25a5933cd06c9108e239a52a82ba797c3d3522645c69cd81b020101c50adeadb7fe15bee45dcb820610cdedcd314eb003000274164fb33c93b4384582c54c30d9a1e2ef219063d03084005edc1da853af2f1f2e67275dbb6ef945d04600b6dd83cfd997cc9ae4173ea61b0c5cc0808fb196681b02"

  	isValid, err := seqAPI.IsValidETHAuthProof(context.Background(), chainID, walletAddress, ethAuthProofString)
  	if err != nil {
  		log.Fatal(err)
  	}
  	fmt.Println("isValid?", isValid)
  }
  ```

  ```shell twoslash [other]
  Please contact our team for assistance with integrations to another target.
  ```
</CodeGroup>

## 仕組みについて

### EIP1271 + EIP6492によるシグネチャ検証に関する注意点

Sequenceのようなスマートウォレットは[EIP1271](https://eips.ethereum.org/EIPS/eip-1271)標準を使用してシグネチャを検証します。

この[EIP1271](https://eips.ethereum.org/EIPS/eip-1271)はコントラクト上で定義された単一の関数です：

```solidity
function isValidSignature(
  bytes32 _hash,
  bytes memory _signature
) public view returns (bytes4 magicValue)
```

最初の`_hash`引数はメッセージダイジェストのハッシュを受け取り、2番目の引数は`_signature`
ウォレットが署名時に返す署名済みペイロードです。

さらに、スマートウォレットは新しいウォレットが作成されるたびにコントラクトをオンチェーンにデプロイするわけではありません。
代わりに、ウォレットアドレスを決定論的に計算し、トランザクションが必要になった時点でのみウォレットがデプロイされます。

この場合、[EIP1271](https://eips.ethereum.org/EIPS/eip-1271)関数を直接使用することはできません。ウォレットコントラクトがまだ存在しないためです。
代わりに、[EIP-6492](https://eips.ethereum.org/EIPS/eip-6492)標準を使用します。これはウォレットコントラクトを起動して[EIP1271](https://eips.ethereum.org/EIPS/eip-1271)関数を呼び出す方法を1つの操作で定義しています。

JavaScript/TypeScriptでのシグネチャ検証には、`0xsequence`ユーティリティ関数を次のように使用できます：

```ts
import { 0xsequence } from '0xsequence'

const wallet = sequence.getWallet()

const isValid = await wallet.utils.isValidSignature(
  walletAddress,
  digest,
  signature,
  chainId
)

console.log(isValid) // returns true/false
```

さらに、`wallet.utils.isValidMessageSignature`または`wallet.utils.isValidTypedDataSignature`
も使用できます。これらは`wallet.utils.isValidSignature`の構文糖衣です。

また、利便性のため、上記のシグネチャ検証関数はEOAまたはスマートウォレットのシグネチャを検証することができます。
これにより、Dappで単一のコードパスを使用して、あらゆる種類のシグネチャを検証し、Metamask、Coinbase、Sequence、WalletConnect、Argent、Rainbowなど、複数のウォレットを同時にサポートすることができます - すべてのEthereum互換ウォレット（EOAまたはスマートウォレット）は*そのまま動作*します。

## レガシーな非EIP6492署名

デフォルトでは、すべての署名メソッドは[EIP-6492](https://eips.ethereum.org/EIPS/eip-6492)エンコードされたシグネチャを生成します。
これにより、シグネチャを検証する前にウォレットをオンチェーンにデプロイする必要がなくなり、これがメッセージに署名する推奨方法です。

ただし、レガシーな非EIP6492シグネチャを生成する必要がある場合は、署名メソッドの最後の引数を`false`に設定することで可能です：

```ts
const signer = wallet.getSigner();
const message = "Hello World!";

const signature = await signer.signMessage(message, { eip6492: false });
console.log(signature);
```

これらのレガシーシグネチャは`wallet.utils.isValidSignature method`を使用して検証できますが、[EIP1271](https://eips.ethereum.org/EIPS/eip-1271)標準で指定されているウォレットコントラクトのisValidSignatureメソッドを使用して検証することもできます。

<Warning>
  非EIP6492シグネチャの署名にはウォレットがオンチェーンにデプロイされている必要があり、
  そのため、メッセージに署名する前にウォレットをオンチェーンにデプロイするようユーザーに促されます。
  ネットワークに手数料がある場合（Ethereumなど）、ユーザーはトランザクション手数料の
  支払いも求められます。
</Warning>
