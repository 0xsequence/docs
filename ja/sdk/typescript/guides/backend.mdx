---
title: バックエンドの統合
description: バックエンドサービスとSequenceを統合する方法を学ぶ
---

# バックエンドの統合

このガイドでは、認証済みセッションを作成しブロックチェーントランザクションを送信するために、Sequenceをバックエンドサービスに統合する方法を説明します。

## 前提条件

開始する前に、以下のものが必要です：

* Sequence Builderからアクセスキーを持つSequenceプロジェクト[Sequence Builder](https://sequence.build)
* Node.js環境
* 必要なパッケージのインストール：

```bash
npm install @0xsequence/auth @0xsequence/network ethers
```

ハードウェアセキュリティモジュール（HSM）のサポートには、関連パッケージをインストールしてください：

```bash
# For Google Cloud KMS
npm install @0xsequence/google-kms-signer

# For AWS KMS
npm install @0xsequence/aws-kms-signer
```

## Sequenceセッションの作成

Sequenceセッションでは、スマートアカウントの作成と認証が可能です。バックエンド環境では、通常シングルサイナーアプローチを使用します。

### プロバイダーの設定

まず、ブロックチェーンに接続するためのプロバイダーを作成します：

```typescript
import { findSupportedNetwork } from "@0xsequence/network";
import type { NetworkConfig } from "@0xsequence/network";
import { ethers } from "ethers";

export const getProvider = async (chainConfig: NetworkConfig) => {
    const provider = new ethers.JsonRpcProvider(process.env.SEQUENCE_RPC_URL, chainConfig.chainId);
    return provider;
};
```

### サイナーオプション

Sequenceはバックエンド統合のために複数のサイナータイプをサポートしています：

#### 1. ローカルプライベートキーサイナー

開発時や簡単なセットアップが必要な場合にこのアプローチを使用します：

```typescript
import { Session } from "@0xsequence/auth";
import { ethers } from "ethers";

export const getLocalSigner = async (chainHandle: string) => {
    const chainConfig = findSupportedNetwork(chainHandle);
    if (!chainConfig) {
        throw new Error(`Chain config not found for chain handle: ${chainHandle}`);
    }

    const provider = await getProvider(chainConfig);
    const walletEOA = new ethers.Wallet(process.env.EVM_PRIVATE_KEY ?? '', provider);
    
    const smartAccount = await Session.singleSigner({
        signer: walletEOA,
        projectAccessKey: process.env.PROJECT_ACCESS_KEY ?? ''
    });

    return smartAccount.account.getSigner(chainConfig.chainId);
};
```

#### 2. Google Cloud KMSサイナー

本番環境では、Google Cloud KMSを使用することでセキュリティが向上します：

```typescript
import { GoogleKmsSigner } from "@0xsequence/google-kms-signer";

export const getGoogleKmsSigner = async (chainHandle: string) => {
    const chainConfig = findSupportedNetwork(chainHandle);
    if (!chainConfig) {
        throw new Error(`Chain config not found for chain handle: ${chainHandle}`);
    }

    const googleKmsSigner = new GoogleKmsSigner({
        project: process.env.PROJECT ?? '',
        location: process.env.LOCATION ?? '',
        keyRing: process.env.KEY_RING ?? '',
        cryptoKey: process.env.CRYPTO_KEY ?? '',
        cryptoKeyVersion: process.env.CRYPTO_KEY_VERSION ?? ''
    });

    const smartAccount = await Session.singleSigner({
        signer: googleKmsSigner,
        projectAccessKey: process.env.PROJECT_ACCESS_KEY ?? ''
    });

    return smartAccount.account.getSigner(chainConfig.chainId);
};
```

#### 3. AWS KMSサイナー

インフラストラクチャにAWSを使用している場合、AWS KMS統合で安全なキー管理が可能です：

```typescript
import { AwsKmsSigner } from "@0xsequence/aws-kms-signer";

export const getAwsKmsSigner = async (chainHandle: string) => {
    const chainConfig = findSupportedNetwork(chainHandle);
    if (!chainConfig) {
        throw new Error(`Chain config not found for chain handle: ${chainHandle}`);
    }

    const awsKmsSigner = new AwsKmsSigner(
        process.env.AWS_REGION ?? '',
        process.env.AWS_KMS_KEY_ID ?? ''
    );

    const smartAccount = await Session.singleSigner({
        signer: awsKmsSigner,
        projectAccessKey: process.env.PROJECT_ACCESS_KEY ?? ''
    });

    return smartAccount.account.getSigner(chainConfig.chainId);
};
```

### サイナー選択のためのファクトリーパターン

環境設定に基づいて適切なサイナーを選択するファクトリー関数を作成できます：

```typescript
export const getSigner = async (chainHandle: string) => {
    if (process.env.SIGNER_TYPE === 'google_kms') { 
        return getGoogleKmsSigner(chainHandle);
    } 
    if (process.env.SIGNER_TYPE === 'aws_kms') {
        return getAwsKmsSigner(chainHandle);
    }
    // Default to local signer
    return getLocalSigner(chainHandle);
};
```

## トランザクションの送信

サイナーを用意したら、トランザクションの送信に使用できます。以下はERC20トークンを送信する方法です：

```typescript
import { ethers } from "ethers";

// Standard ERC20 ABI for the transfer function
const erc20Abi = [
  "function transfer(address to, uint256 amount) returns (bool)",
  "function balanceOf(address owner) view returns (uint256)",
  "function decimals() view returns (uint8)"
];

async function sendERC20Tokens(
    chainId: string, 
    tokenAddress: string, 
    recipientAddress: string, 
    amount: string
) {
    // Get the signer for the specified chain
    const signer = await getSigner(chainId);
    
    // Create a contract instance
    const tokenContract = new ethers.Contract(tokenAddress, erc20Abi, signer);
    
    // Get token decimals
    const decimals = await tokenContract.decimals();
    
    // Convert the amount to the correct units based on decimals
    const amountInSmallestUnit = ethers.parseUnits(amount, decimals);
    
    // Send the transaction
    const tx = await tokenContract.transfer(recipientAddress, amountInSmallestUnit);
    
    // Wait for the transaction to be mined
    const receipt = await tx.wait();
    
    if (receipt?.status === 0) {
        throw new Error('Transaction reverted');
    }
    
    return {
        txHash: receipt?.hash,
        txUrl: `https://${chainId}.etherscan.io/tx/${receipt?.hash}`
    };
}
```

## API統合の例

FastifyのAPIエンドポイントにERC20転送機能を統合する方法は以下の通りです：

```typescript
import { FastifyInstance } from "fastify";
import { getSigner } from "../utils/wallet";
import { ethers } from "ethers";

// ERC20 token transfer API route
export async function erc20TransferRoute(fastify: FastifyInstance) {
    fastify.post('/transfer/erc20/:chainId', async (request, reply) => {
        try {
            const { chainId } = request.params;
            const { tokenAddress, recipient, amount } = request.body;

            // Validate inputs
            if (!tokenAddress || !ethers.isAddress(tokenAddress)) {
                return reply.code(400).send({ error: 'Invalid token address' });
            }
            
            if (!recipient || !ethers.isAddress(recipient)) {
                return reply.code(400).send({ error: 'Invalid recipient address' });
            }
            
            if (!amount || isNaN(parseFloat(amount)) || parseFloat(amount) <= 0) {
                return reply.code(400).send({ error: 'Invalid amount' });
            }

            // Get the signer for the specified chain
            const signer = await getSigner(chainId);
            
            // Create a contract instance
            const erc20Abi = [
                "function transfer(address to, uint256 amount) returns (bool)",
                "function balanceOf(address owner) view returns (uint256)",
                "function decimals() view returns (uint8)"
            ];
            
            const tokenContract = new ethers.Contract(tokenAddress, erc20Abi, signer);
            
            // Get token decimals
            const decimals = await tokenContract.decimals();
            
            // Convert the amount to the correct units based on decimals
            const amountInSmallestUnit = ethers.parseUnits(amount, decimals);
            
            // Send the transaction
            const tx = await tokenContract.transfer(recipient, amountInSmallestUnit);
            
            // Wait for the transaction to be mined
            const receipt = await tx.wait();
            
            return {
                success: receipt?.status === 1,
                txHash: receipt?.hash,
                txUrl: `https://${chainId}.etherscan.io/tx/${receipt?.hash}`
            };
        } catch (error) {
            request.log.error(error);
            return reply.code(500).send({
                success: false,
                error: error instanceof Error ? error.message : 'Failed to transfer tokens'
            });
        }
    });
}
```

## ベストプラクティス

1. **環境変数**：すべての機密情報（プライベートキー、APIキー）を環境変数に保存してください。

2. **エラー処理**：ブロックチェーントランザクションの周りに堅牢なエラー処理を実装してください。

3. **セキュリティ**：本番環境では、生のプライベートキーの代わりにGoogle KMSやAWS KMSなどのHSMソリューションを使用してください。

4. **トランザクションの監視**：特に確認に時間がかかる可能性のあるトランザクションのステータスを監視するシステムを実装してください。

5. **リトライメカニズム**：特にネットワーク混雑時の失敗したトランザクションに対するリトライロジックを実装してください。

6. **チェーンの選択**：サポートされているネットワークに接続していることを確認するために`findSupportedNetwork`ユーティリティを使用してください。

## 設定例

典型的な`.env`ファイルは以下のようになります：

```
# Common configuration
PROJECT_ACCESS_KEY=your-sequence-project-access-key
SEQUENCE_RPC_URL=https://mainnet-sequencer.sequence.app
SIGNER_TYPE=local|google_kms|aws_kms

# Local signer configuration
EVM_PRIVATE_KEY=your-private-key

# Google KMS configuration
PROJECT=your-gcp-project
LOCATION=us-central1
KEY_RING=your-keyring
CRYPTO_KEY=your-key
CRYPTO_KEY_VERSION=1

# AWS KMS configuration
AWS_REGION=us-east-1
AWS_KMS_KEY_ID=your-key-id
```

このセットアップにより、Sequenceを使用してバックエンドサービスから複数のブロックチェーンネットワークに安全に接続し、トランザクションを実行できます。
