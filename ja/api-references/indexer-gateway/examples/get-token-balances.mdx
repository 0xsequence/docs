---
title: Sequence Indexer Gateway API - ERC20、ERC721、およびERC1155トークンとメタデータの取得
description: トークンAPIを使用すると、複数のEthereumネットワークにわたって任意のウォレットからERC20、ERC721、およびERC1155トークンとメタデータのリストを取得できます。
---

# トークン残高

以下の例では、`GetTokenBalances`メソッドを使用します：
Sequence Indexer Gateway から：

## `GetTokenBalances`

* リクエスト: POST /rpc/IndexerGateway/GetTokenBalances
* Content-Type: application/json
* ボディ（JSON形式）：
  * `chainIds`（\[]int - オプション）-- 指定されたIDに一致するチェーンの結果のみを返します。
  * `networks`（\[]string - オプション）-- 指定された名前に一致するチェーンの結果のみを返します。
  * `accountAddress`（string）-- ウォレットアカウントアドレス
  * `contractAddress`：（string -- オプション）-- トークンコントラクトアドレス
  * `tokenID`：（string -- オプション）-- トークンのID
  * `includeMetadata`（boolean - オプション - デフォルト：false）-- レスポンスにトークンメタデータを含めるかどうかを切り替えます
  * `includeCollectionTokens`（boolean - オプション - デフォルト：true）-- レスポンスでERC721 / ERC1155トークンを単一のサマリーアイテムとして表示するかどうかを切り替えます
  * `metadataOptions`（object - オプション）-- メタデータの追加オプション
    * `verifiedOnly`（boolean - オプション）-- スパムを減らすために'検証済み'のコントラクトのみを返します
    * `unverifiedOnly`（boolean - オプション）-- '未検証'のコントラクトのみを返します
    * `includeContracts`（\[]string - オプション）-- verifiedOnlyが有効な場合でも、常に含める特定のコントラクトアドレスのリスト

これらの例は[すべてのトークンを取得する例](/api-references/indexer/examples/fetch-tokens)に基づいています。

### 複数のEthereumネットワークでアカウントからトークン残高とメタデータを取得する

例：以下のアカウントのトークン残高とメタデータを取得する
`0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9`すべてのチェーンにわたって。

<CodeGroup>
  ```shell [Curl]
  curl -X POST \
    -H "Content-Type: application/json" \
    -H "X-Access-Key: AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY" \
    https://indexer.sequence.app/rpc/IndexerGateway/GetTokenBalances \
    -d '{
      "accountAddress": "0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9", 
      "includeMetadata": true,
      "metadataOptions": {
        "verifiedOnly": true
      }
    }'
  ```

  ```ts [Typescript]
  import { SequenceIndexerGateway } from '@0xsequence/indexer'

  const INDEXER_TOKEN = 'AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY';
  const ACCOUNT_ADDRESS = '0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9'

  const indexerGateway = new SequenceIndexerGateway(
    'https://indexer.sequence.app',
    INDEXER_TOKEN
  )

  const res = await indexerGateway.getTokenBalances({
    // chainIds: [1, 4, 137], /* limit results to specific chains */
    accountAddress: ACCOUNT_ADDRESS,
    includeMetadata: true,
    metadataOptions: {
      verifiedOnly: true
    }
  })

  res.balances.forEach(({chainId, results}) => {
    if (results.length === 0) {
      return
    }

    console.log(`chainId: ${chainId} → ${results.length} tokens found.`);
    results.forEach(token => {
      console.log(`\ttoken: ${token.contractAddress} (${token.contractInfo?.symbol}): ${token.balance}`);
    });
  })

  /*
  Sample output:
  chainId: 1946 → 1 tokens found.
          token: 0x5bcbc265a86fda3502e12cf17947445f7fd4402a (MINE): 1
  chainId: 421614 → 2 tokens found.
          token: 0x1f3abc3c5e4ac0601a21183380ed426e06ec694a (MINE): 2
    ""       token: 0x631980c251af5b4e71429ccc95f77155d75b89d4 (PCKX): 1
  */
  ```

  ```go [Go]
  package main

  import (
  	"context"
  	"fmt"
  	"log"
  	"net/http"

  	"github.com/0xsequence/go-sequence/indexer"
  )

  const indexerToken = "AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY"

  func main() {
  	ctx := context.TODO()

  	seqIndexerGW := indexer.NewIndexerGatewayClient(
  		"https://indexer.sequence.app",
  		http.DefaultClient,
  	)

  	authCtx, err := indexer.WithHTTPRequestHeaders(ctx, http.Header{
  		"X-Access-Key": []string{indexerToken},
  	})

  	includeMetadata := true
  	accountAddress := "0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9"

  	chainIDs := make([]uint64, 0)

  	// chainIDs = []uint64{1, 100, 137} // optional filter by chainID

  	metadataOptions := indexer.MetadataOptions{
  		VerifiedOnly: true,
  	}

  	_, tokenBalances, err := seqIndexerGW.GetTokenBalances(
      authCtx, 
      chainIDs,
      nil, 
      &accountAddress, 
      nil, 
      nil, 
      &includeMetadata, 
      &metadataOptions, 
      nil,
      nil,
    )
  	if err != nil {
  		log.Fatal(err)
  	}

  	for _, tb := range tokenBalances {
  		if len(tb.Results) == 0 {
  			continue
  		}
  		fmt.Printf("ChainID: %d -> %d tokens found\n", tb.ChainID, len(tb.Results))
  		for _, tokenBalance := range tb.Results {
  			fmt.Printf("\tToken: %q (%q): %s\n", tokenBalance.ContractAddress, tokenBalance.ContractInfo.Symbol, tokenBalance.Balance)
  		}
  	}
  }

  /*
  Sample output:
  ChainID: 1 -> 7 tokens found
          Token: "0xc770eefad204b5180df6a14ee197d99d808ee52d" ("FOX"): 58899592885266406938
          Token: "0x6b175474e89094c44da98b954eedeac495271d0f" ("DAI"): 5021334051688125324
          Token: "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48" ("USDC"): 221887067
  */
  ```
</CodeGroup>

<br />

<Note>
  **プロヒント：ERC721/1155トークンIDの取得**

  デフォルトでは、`GetTokenBalances`各コントラクトから最大1つのトークンインスタンスを返すことに注意してください。ERC721/1155トークン残高を取得するには、`contractAddress`を`GetTokenBalances`メソッドに渡す必要があります。
  これにより、`accountAddress`が所有する指定された
  `contractAddress`のすべてのトークンが返されます。詳細については以下のセクションを参照してください。
</Note>

### ERC721およびERC1155コレクションのトークンID、残高、メタデータを取得する

例：Polygonネットワーク上の特定のアカウントとトークンコントラクトのトークン残高を取得する

<CodeGroup>
  ```shell [Curl]
  curl -X POST \
    -H "Content-Type: application/json" \
    -H "X-Access-Key: AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY" \
    https://indexer.sequence.app/rpc/IndexerGateway/GetTokenBalances \
    -d '{
      "chainIds": [137],
      "accountAddress": "0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9",
      "contractAddress": "0x631998e91476DA5B870D741192fc5Cbc55F5a52E",
      "includeMetadata": true,
      "metadataOptions": {
        "verifiedOnly": true
      }
    }'

  ```

  ```typescript [Typescript]
  import { SequenceIndexerGateway } from '@0xsequence/indexer'

  const INDEXER_TOKEN = 'AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY';
  const ACCOUNT_ADDRESS = '0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9';
  const CONTRACT_ADDRESS = '0x631998e91476DA5B870D741192fc5Cbc55F5a52E';

  const indexerGateway = new SequenceIndexerGateway(
    'https://indexer.sequence.app',
    INDEXER_TOKEN
  )

  const res = await indexerGateway.getTokenBalances({
    chainIds: [137],
    accountAddress: ACCOUNT_ADDRESS,
    contractAddress: CONTRACT_ADDRESS,
    includeMetadata: true,
    metadataOptions: {
      verifiedOnly: true
    }
  })

  res.balances.forEach(({ chainId, results }) => {
    if (results.length === 0) {
      return
    }

    console.log(`chainId: ${chainId} → ${results.length} tokens found.`);
    results.forEach(token => {
      console.log(`\ttoken: ${token.contractAddress} (${token.contractInfo?.symbol}): ${token.balance}`);
    });
  });

  ```

  ```go [Go]
  package main

  import (
  	"context"
  	"fmt"
  	"log"
  	"net/http"

  	"github.com/0xsequence/go-sequence/indexer"
  )

  const indexerToken = "AQAAAAAAAF_JvPALhBthL7VGn6jV0YDqaFY"

  func main() {
  	ctx := context.TODO()

  	seqIndexerGW := indexer.NewIndexerGatewayClient(
  		"https://indexer.sequence.app",
  		http.DefaultClient,
  	)

  	authCtx, err := indexer.WithHTTPRequestHeaders(ctx, http.Header{
  		"X-Access-Key": []string{indexerToken},
  	})
  	if err != nil {
  		log.Fatal(err)
  	}

  	includeMetadata := true
  	accountAddress := "0x8e3E38fe7367dd3b52D1e281E4e8400447C8d8B9"
  	contractAddress := "0x631998e91476DA5B870D741192fc5Cbc55F5a52E"
  	chainIDs := []uint64{137}

  	metadataOptions := indexer.MetadataOptions{
  		VerifiedOnly: true,
  	}

  	_, tokenBalances, err := seqIndexerGW.GetTokenBalances(
  		authCtx,
  		chainIDs,
  		nil,
  		&accountAddress,
  		&contractAddress,
  		nil,
  		&includeMetadata,
  		&metadataOptions,
  		nil,
  		nil,
  	)
  	if err != nil {
  		log.Fatal(err)
  	}

  	for _, tb := range tokenBalances {
  		if len(tb.Results) == 0 {
  			continue
  		}
  		fmt.Printf("ChainID: %d -> %d tokens found\n", tb.ChainID, len(tb.Results))
  		for _, tokenBalance := range tb.Results {
  			fmt.Printf("\tToken: %q (%q): %s\n", tokenBalance.ContractAddress, tokenBalance.ContractInfo.Symbol, tokenBalance.Balance)
  		}
  	}
  }
  ```
</CodeGroup>
